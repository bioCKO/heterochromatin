
<<>>=
library("vecsets")
#grp1 <- sort(as.numeric(c(round(rlnorm(10, 1)),1,1,1,1,1)))
#grp2 <- sort(as.numeric(round(rlnorm(10, 1))))

#getLengthSignificance(valuesEmpty, values, file)

getLengthSignificance <- function(grp2, grp1, comparedTo) { # empty motif
  common<-vintersect(grp1, grp2, multiple = TRUE)
  values_not_in_empty_windows<-vsetdiff(grp1, common, multiple = TRUE)
  leftovers_in_empty_windows<-vsetdiff(grp2, common, multiple = TRUE)
  pvalue<-ks.test(grp1,grp2)$p.value #perform Kolmogorov-Smirnov Tests
  #plot(table(values_not_in_empty_windows)[-1],col="darkgreen",main=round(pvalue,2),ylab="gap lengths")
  return(pvalue)
}
@


<<plot error profiles for different motifs>>=
par(
  mfrow = c(4, 4),
  cex.main = 1.3,
  cex.sub = 1.4,
  cex.axis = 1.2
)
library("plyr")
library("dplyr")
library("hash")
library("data.table")
setwd("/Users/alice/Desktop/projects/kinetics/errors_will/merged/formatted")
filenames <- list.files(pattern = "*mf", full.names = FALSE)
#filenames <- filenames[grepl("FeatureOnly", filenames)]
filenames <- filenames[grep("Feature", filenames,invert=FALSE)]
filenames <- filenames[grep("EmptyTmp.txt", filenames,invert=TRUE)]
set.seed(3)

#grp.1 <- round(rlnorm(100, 6)) # With Widget
#grp.2 <- round(rlnorm(100, 6)) # Original page

getPvalue <- function(grp.1, grp.2, comparedTo) {
  groups <- c(rep(1, length(grp.1)), rep(2, length(grp.2)))
  data <- c(grp.1, grp.2)
  
  diff(by(data, groups, mean))
  
  s <- sample(groups, length(groups), FALSE)
  diff(by(data, s, mean))
  
  max.iter <- 500
  examples <- unlist(lapply(1:max.iter, function(x) {
    diff(by(data, sample(groups, length(groups), FALSE), mean))
  }))
  
  test.diff <- diff(by(data, groups, mean))
  
  # two-tailed test
  pvalue <-
    (sum(abs(examples) > abs(test.diff)) + 1) / (max.iter + 1) #from http://danielnee.com/tag/p-value/
  
  hist(
    examples,
    col = ifelse(pvalue < 0.05, 'red', 'blue'),
    breaks = 50,
    main = paste("RPerm", main = gsub(".txt", "", gsub(
      "ERRORS", "", gsub("10000.", "", gsub(".mf", "", comparedTo))
    ))),
    xlab = "",
    sub = paste(
      "pvalue: ",
      round(pvalue, 2),
      " | C:",
      length(grp.1),
      " | T:",
      length(grp.2),
      sep = ""
    )
  )
  abline(v = test.diff, col = "black", lwd = 4)
  return(pvalue)
}

summary <- NULL
valTable <- NULL
for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0) {
      #load motif windows
      dataOriginal <-
        read.table(
          file,
          header = F,
          sep = "$",
          col.names = c("V1", "V2", "V3"),
          fill = TRUE
        )
      data <-
        as.data.frame(setDT(tstrsplit(as.character(dataOriginal[,1]), " ", fixed = TRUE))[]) #split by spaces
      data <- data[complete.cases(data),]
      row <-
        cbind(
          file,
          as.numeric(as.character(median(
            as.numeric(as.character(as.vector(data$V8))), na.rm = TRUE
          ))),
          as.numeric(as.character(median(
            as.numeric(as.character(as.vector(data$V9))), na.rm = TRUE
          ))),
          as.numeric(as.character(median(
            as.numeric(as.character(as.vector(data$V10))), na.rm = TRUE
          ))),
          as.numeric(as.character(median(
            as.numeric(as.character(as.vector(data$V11))), na.rm = TRUE
          )))
        )
      
      summary <- rbind(summary, row)
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Initial read.table didn't work!:  ", err))
  })
}
print(summary)
summary <- summary[complete.cases(summary),]
summary <- as.data.frame(summary)
colnames(summary) <-
  c("file", "h8", "h9", "h10", "h11") #"total", "insertions", "deletions", "mismatches"
summary <-
  plyr::arrange(summary, as.numeric(as.character(summary$h8)), decreasing =
                  FALSE)
print(summary)
ordered <- summary$file

h8 <- hash()
h9 <- hash()
h10 <- hash()
h11 <- hash()
hpvalue <- hash()

tryCatch({
  dataEmptyOriginal <-
    read.table(
      "merged_Empty.mf",
      header = F,
      sep = "$",
      col.names = c("V1", "V2", "V3"),
      fill = TRUE
    )
  dataEmpty <-
    as.data.frame(setDT(tstrsplit(as.character(dataEmptyOriginal[,1]), " ", fixed = TRUE))[]) #split by spaces
  
  dataEmpty <- dataEmpty[complete.cases(dataEmpty), ]
  valuesEmpty <- as.numeric(as.character(as.vector(dataEmpty$V8)))
  
  insertionsEmpty <-
    sort(as.numeric(unlist(strsplit(
      gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V2)), ", "
    ))))
  deletionsEmpty <-
    sort(as.numeric(unlist(strsplit(
      gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V3)), ", "
    ))))
  
},
error = function(err) {
  # error handler picks up where error was generated
  print(paste("Default empty file does not exist.", err))
})

#PLOT ordered from lowest error rate to highest
for (file in (ordered)) {
  print(file)
  tryCatch({
    #load motif windows
    dataOriginal <-
      read.table(
        file,
        header = F,
        sep = "$",
        col.names = c("V1", "V2", "V3"),
        fill = TRUE
      )
    data <-
      as.data.frame(setDT(tstrsplit(as.character(dataOriginal[, 1]), " ", fixed = TRUE))[]) #split by spaces
    values <- as.numeric(as.vector(data$V8))
    values <- values[!is.na(values)]
    
    insertions <-
      sort(as.numeric(unlist(strsplit(
        gsub("c\\(", "", gsub("\\)", "", dataOriginal$V2)), ", "
      ))))
    deletions <-
      sort(as.numeric(unlist(strsplit(
        gsub("c\\(", "", gsub("\\)", "", dataOriginal$V3)), ", "
      ))))
    
    
    if (length(values) >= 30) {
      #we are only interested in sufficiently populated motifs
      #populate hashes
      h8[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V8))
      h9[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V9))
      h10[gsub("ERROR.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V10))
      h11[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V11))
      
      hist(
        values,
        col = "gold",
        xlab = "% error",
        main = gsub(".txt", "", gsub(
          "ERRORS", "", gsub("10000.", "", gsub(".mf", "", file))
        )),
        xlim = c(0, 100),
        sub = paste("n=", length(values), " errorRate=", round(mean(values), 2), sep =
                      "")
      )
      
      #load empty windows
      emptyFile <- gsub(".mf", ".mfEmptyTmp.txt", file)
      
      if (file.exists(emptyFile)) {
        print("empty file exists, will use matching file")
        
        #individial empty files
        dataEmptyOriginal <-
          read.table(
            emptyFile,
            header = F,
            sep = "$",
            col.names = c("V1", "V2", "V3"),
            fill = TRUE
          )
        dataEmpty <-
          as.data.frame(setDT(tstrsplit(
            as.character(dataEmptyOriginal[, 1]), " ", fixed = TRUE
          ))[]) #split by spaces
        dataEmpty <- dataEmpty[complete.cases(dataEmpty),]
        valuesEmpty <-
          as.numeric(as.character(as.vector(dataEmpty$V8)))
        
        insertionsEmpty <-
          sort(as.numeric(unlist(strsplit(
            gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V2)), ", "
          ))))
        deletionsEmpty <-
          sort(as.numeric(unlist(strsplit(
            gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V3)), ", "
          ))))
        
      } else {
        print("empty file does not exist, will use default file")         #one empty file for all
        
      }
      #compare to either individual all default file with empty values
      #getPvalue(valuesEmpty, values, file)
      hpvalue[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = round(as.numeric(getPvalue(valuesEmpty, values, file)),2) #save pvalue and plot histogram
      print(getLengthSignificance(insertionsEmpty, insertions, file))
      print(getLengthSignificance(deletionsEmpty, deletions, file))
    } else {
      print("Too small sample size.")
    }
  },
  error = function(err) {
    print(file)
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ", err))
  })
}
@

<<>>=
par(mfrow = c(1, 1))

#errorTypes = c("h8", "h9", "h10", "h11")
errorTypes = c("h8")

for (et in errorTypes) {
  switch(
    et,
    #errorNames = c("TOTAL", "INSERTIONS", "DELETIONS", "MISMATCHES")
    h8 = {
      summary <-
        plyr::arrange(summary, as.numeric(as.character(summary$h8)), decreasing = FALSE)
      errorName = "TOTAL"
    },
    h9 = {
      summary <-
        plyr::arrange(summary, as.numeric(as.character(summary$h9)), decreasing = FALSE)
      errorName = "INSERTIONS"
    },
    h10 = {
      summary <-
        plyr::arrange(summary, as.numeric(as.character(summary$h10)), decreasing = FALSE)
      errorName = "DELETIONS"
    },
    h11 = {
      summary <-
        plyr::arrange(summary, as.numeric(as.character(summary$h11)), decreasing = FALSE)
      errorName = "MISMATCHES"
    }
  )
  #print(summary)
  ordered <- summary$file
  names <- gsub("ERRORS", "", gsub(".mf.txt", "", ordered))
  #percErrorTotal
  box = boxplot(
    values(get(et))[names],
    col = "gold",
    names = TRUE,
    frame = FALSE,
    axis = FALSE,
    labels = TRUE,
    xaxt = "n",
    outline = FALSE,
    border = "gray",
    ylab = "%",
    plot = FALSE
  )
  
  annotation <- box$n
  annotation[annotation != 0] <- names[which(box$n != 0)]
  annotation[annotation == 0] <- NA
  
  significance <- as.numeric(values(hpvalue)[names])
  
  n <- length(box$n)
  largest_value <- max(box$n)
  #perc = round(box$n / largest_value * 100, 0) # compute sample size percentages (the maximum sample size is 1)
  perc = round(significance / 1 * 100, 0) # compute pvalue percentages <0,1>
  perc<-as.numeric(na.omit(perc))
  
  colfunc <- colorRampPalette(c("firebrick1","white","white","white","white","white","white","white","white","white"))
  col_perc = colfunc(101)[perc+1] # the maximum sample size has red, indexed from 1
  colscale <- box$n
  colscale[colscale == 0] <-NA
  colscale[!is.na(colscale)] <- col_perc
  
  colscale[grep("Empty", annotation)] <-
    "green"  #assign green to empty windows
  
  
  bxp(
    box,
    outline = FALSE,
    pars = list(
      whisklty = 3,
      staplewex = 0.8,
      boxfill = colscale
    ),
    xlab = "Motif",
    ylab = "% error rate",
    xaxt = 'n',
    yaxs ="i",
    main = errorName,
    border= "darkgray"
  )
  
  library("SDMTools")
  #points for the gradient legend
#pnts = cbind(x =c(0.8,20,20,0.8), y =c(20,20,0.8,0.8))

xl <- 92
yb <- 10
xr <- 93
yt <- 20

rect(
     xl,
     head(seq(yb,yt,(yt-yb)/100),-1),
     xr,
     tail(seq(yb,yt,(yt-yb)/100),-1),
     col=colfunc(101),
     lwd=0.075
    )
mtext(seq(from=0,to=1,by=0.1),side=4,at=tail(seq(yb-1,yt,(yt-yb)/10),-1)+0.1,las=2,cex=0.7)
  
  text(
    1:length(names),
    25,
    #1 * median(as.numeric(unlist(values(get(et))[names][grep("Empty", names)]))),
    labels = gsub("merged_", "", gsub(".mf", "", gsub("FeatureOnly", "", annotation))),
    srt = 90,
    col = "black",
    cex = 0.7
  )
  abline(h = median(as.numeric(unlist(values(
    get(et)
  )[names][grep("Empty", names)])), na.rm = TRUE), col = "black")
}
@

<<>>=
colfunc <- colorRampPalette(c("white","white", "white", "white","white","white", "white", "white","white","red"))
plot(1:100,1:100,pch=20,col=colfunc(100))
abline(h=90,col="black")
@


\end{document}
<<>>=
par(mfrow=c(3,2))
setwd("/Users/alice/Desktop/projects/kinetics/errors_will/lengths")
filenames <- list.files(pattern="*mf.txt", full.names=FALSE)

for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0){
      name<-gsub("22.ERRORS10000onlyFeature.","",gsub(".mf.txt","",file))
      #load motif windows
      data<-as.data.frame(read.table(file, header = F,sep='$'))
      insertions<-sort(as.numeric(unlist(strsplit(gsub("c\\(", "", gsub("\\)", "", data$V2)),", "))))
      deletions<-sort(as.numeric(unlist(strsplit(gsub("c\\(", "", gsub("\\)", "", data$V3)),", "))))
      print(dim(data))
      plot(table(sort(as.numeric(unlist(insertions)))),col="orange",xlab="insertions length",main=file,freq=TRUE,xlim=c(0,20))
      #abline(v=nchar(name),col="red")
      plot(table(sort(as.numeric(unlist(deletions)))),col="cyan",xlab="deletions length",main=file,freq=TRUE,xlim=c(0,20))
      #abline(v=nchar(name),col="red")
    }
  }, error = function(err) {
    print(file)
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ",err))
  })
}
@

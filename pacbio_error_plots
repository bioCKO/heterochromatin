
<<plot error profiles for different motifs>>=
par(
  mfrow = c(4, 4),
  cex.main = 1.3,
  cex.sub = 1.4,
  cex.axis = 1.2
)
library("plyr")
library("dplyr")
library("hash")
library("data.table")
setwd("/Users/alice/Desktop/projects/kinetics/errors_will")
filenames <- list.files(pattern = "*mf.txt", full.names = FALSE)
#filenames <- filenames[grepl("FeatureOnly", filenames)]
filenames <- filenames[grepl("windows", filenames)]

set.seed(3)

#grp.1 <- round(rlnorm(100, 6)) # With Widget
#grp.2 <- round(rlnorm(100, 6)) # Original page

getPvalue <- function(grp.1, grp.2, comparedTo) {
  groups <- c(rep(1, length(grp.1)), rep(2, length(grp.2)))
  data <- c(grp.1, grp.2)
  
  diff(by(data, groups, mean))
  
  s <- sample(groups, length(groups), FALSE)
  diff(by(data, s, mean))
  
  max.iter <- 500
  examples <- unlist(lapply(1:max.iter, function(x) {
    diff(by(data, sample(groups, length(groups), FALSE), mean))
  }))
  
  test.diff <- diff(by(data, groups, mean))
  
  # one-tailed test
  pvalue <- (sum(examples > test.diff) + 1) / (max.iter + 1)
  
  hist(
    examples,
    col = ifelse(pvalue <= 0.1, 'red', 'blue'),
    breaks = 50,
    main = paste("RPerm", main = gsub(".txt", "", gsub(
      "ERRORS", "", gsub("10000.", "", gsub(".mf", "", comparedTo))
    ))),
    xlab = "",
    sub = paste(
      "pvalue: ",
      round(pvalue, 2),
      " | C:",
      length(grp.1),
      " | T:",
      length(grp.2),
      sep = ""
    )
  )
  abline(v = test.diff, col = "black", lwd = 4)
}

summary <- NULL
valTable <- NULL
for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0) {
      #load motif windows
      data <-
        read.table(
          file,
          header = F,
          sep = "$",
          col.names = c("V1", "V2", "V3"),
          fill = TRUE
        )[, 1] #skip information about insertions and deletions
      data <-
        as.data.frame(setDT(tstrsplit(as.character(data), " ", fixed = TRUE))[]) #split by spaces
      data <- data[complete.cases(data), ]
      values <- as.numeric(as.character(as.vector(data$V8)))
      row <- cbind(file, as.numeric(as.character(median(values, na.rm = TRUE))))
      
      summary <- rbind(summary, row)
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Initial read.table didn't work!:  ", err))
  })
}
print(summary)
summary <- summary[complete.cases(summary), ]
summary <- as.data.frame(summary)
colnames(summary) <- c("file", "errorRate")
summary <-
  plyr::arrange(summary, as.numeric(as.character(summary$errorRate)), decreasing =
                  FALSE)
print(summary)
ordered <- summary$file

h8 <- hash()
h9 <- hash()
h10 <- hash()
h11 <- hash()

tryCatch({
  dataEmpty <-
    read.table(
      "Empty.mf.txt",
      header = F,
      sep = "$",
      col.names = c("V1", "V2", "V3"),
      fill = TRUE
    )[, 1] #skip information about insertions and deletions
  dataEmpty <-
    as.data.frame(setDT(tstrsplit(as.character(dataEmpty), " ", fixed = TRUE))[]) #split by spaces
  
  dataEmpty <- dataEmpty[complete.cases(dataEmpty),]
  valuesEmpty <- as.numeric(as.character(as.vector(dataEmpty$V8)))
  
},
error = function(err) {
  # error handler picks up where error was generated
  print(paste("Default empty file does not exist.", err))
})

#PLOT ordered from lowest error rate to highest
for (file in (ordered)) {
  print(file)
  tryCatch({
    #load motif windows
    data <-
      read.table(
        file,
        header = F,
        sep = "$",
        col.names = c("V1", "V2", "V3"),
        fill = TRUE
      )[, 1] #skip information about insertions and deletions
    data <-
      as.data.frame(setDT(tstrsplit(as.character(data), " ", fixed = TRUE))[]) #split by spaces
    values <- as.numeric(as.vector(data$V8))
    values <- values[!is.na(values)]
    
    
    if (length(values) >= 30) { #we are only interested in sufficiently populated motifs
      #populate hashes
      h8[gsub("ERRORS.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V8))
      h9[gsub("ERRORS.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V9))
      h10[gsub("ERRORS.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V10))
      h11[gsub("ERRORS.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V11))
      
      hist(
        values,
        col = "gold",
        xlab = "% error",
        main = gsub(".txt", "", gsub(
          "ERRORS", "", gsub("10000.", "", gsub(".mf", "", file))
        )),
        xlim = c(0, 100),
        sub = paste("n=", length(values), " errorRate=", round(mean(values), 2), sep =
                      "")
      )
      
      #load empty windows
      emptyFile <- gsub(".txt", "EmptyTmp.txt", file)
      
      if (file.exists(emptyFile)) {
        print("empty file exists, will use matching file")
        
        #individial empty files
        dataEmpty <-
          read.table(
            emptyFile,
            header = F,
            sep = "$",
            col.names = c("V1", "V2", "V3"),
            fill = TRUE
          )[, 1] #skip information about insertions and deletions
        dataEmpty <-
          as.data.frame(setDT(tstrsplit(
            as.character(dataEmpty), " ", fixed = TRUE
          ))[]) #split by spaces
        dataEmpty <- dataEmpty[complete.cases(dataEmpty), ]
        valuesEmpty <-
          as.numeric(as.character(as.vector(dataEmpty$V8)))
        
      } else {
        print("empty file does not exist, will use default file")         #one empty file for all
        
      }
      #compare to either individual all default file with empty values
      getPvalue(valuesEmpty, values, file)
    } else {
      print("Too small sample size.")
    }
  },
  error = function(err) {
    print(file)
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ", err))
  })
}

@

<<big stat>>=
par(mfrow=c(1,1))
library("DescTools")
setwd("/Users/alice/Desktop/projects/kinetics/errors_will/old/November17th/22features")
filenames <- list.files(pattern="*mf.txt", full.names=FALSE)
names<-(gsub("22.ERRORS10000onlyFeature.","",gsub(".mf.txt","",ordered)))
#names<-tail(names,n=10)
@

<<>>=

#percErrorTotal
box=boxplot(values(h8)[names],col="gold",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError TOTAL",ylim=c(0,60),outline=FALSE,border="gray",ylab="%",plot=FALSE)

#box=boxplot(values(h8)[names]~factor(names),plot=FALSE)
#box$stats=as.matrix(Reduce(cbind,tapply(values(h8)[names],factor(names),quantile,probs=c(0.05,0.25,0.5,0.75,0.95),na.rm=TRUE,SIMPLIFY=FALSE))) # change whiskers

n <- length(box$n)
second_largest_value<-sort(box$n,partial=n-1)[n-1]
perc=round(box$n/second_largest_value*100000,0) # compute sample size percentages (the maximum sample size is 1)

col_perc=rev(heat.colors(100000))[perc] # the maximum sample size has red
col_perc[which(box$n==max(box$n))]<-"green"  #assign green to empty windows

bxp(box,outline=FALSE,pars=list(whisklty=3,staplewex=0.8,boxfill=col_perc),xlab="motif",xaxt='n')
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h8)),las=3)
text(1:length(names),50,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h8[["Empty"]], na.rm = TRUE),col="blue")

@

<<other hists>>=
#percErrorIns
boxplot(values(h9)[names],col="orange",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError INSERTIONS",ylim=c(0,30),outline=FALSE,border="gray",ylab="%")
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h9)),las=3)
text(1:length(names),20,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h9[["Empty"]], na.rm = TRUE),col="blue")

#percErrorDel
boxplot(values(h10)[names],col="cyan",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError DELETIONS",ylim=c(0,30),outline=FALSE,border="gray",ylab="%")
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h10)),las=3)
text(1:length(names),15,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h10[["Empty"]], na.rm = TRUE),col="blue")

#percErrorMism
boxplot(values(h11)[names],col="green",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError MISMATCHES",ylim=c(0,40),outline=FALSE,border="gray",ylab="%")
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h11)),las=3)
text(1:length(names),35,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h11[["Empty"]], na.rm = TRUE),col="blue")
@

<<>>=


summary<-NULL
for (file in (ordered)) {
  tryCatch({
    if (file.size(file) > 0){
      
      print(file)
      #load motif windows
      data<-as.data.frame(read.table(file, header = F,col.names=c("V1","V2","V3","V4","V5","V6","V7","V8","V9","V10","V11"), fill=TRUE))
      data<-data[complete.cases(data),]
      values<-as.numeric(as.character(as.vector(data$V8)))
      row<-cbind(file,as.numeric(as.character(median(values, na.rm = TRUE))))
      
      if (length(values) >= 50) {
        boxplot(values,col="gold",main=gsub(".ERRORS10000onlyFeature","", file),ylim=c(0,100),frame=F)
      }
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ",err))
  })
}
@






\end{document}
<<>>=
par(mfrow=c(3,2))
setwd("/Users/alice/Desktop/projects/kinetics/errors_will/lengths")
filenames <- list.files(pattern="*mf.txt", full.names=FALSE)

for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0){
      name<-gsub("22.ERRORS10000onlyFeature.","",gsub(".mf.txt","",file))
      #load motif windows
      data<-as.data.frame(read.table(file, header = F,sep='$'))
      insertions<-strsplit(gsub(" c\\(","",gsub("\\) ","",data$V2)),", ")
      deletions<-strsplit(gsub(" c\\(","",gsub("\\) ","",data$V3)),", ")
      print(dim(data))
      plot(table(sort(as.numeric(unlist(insertions)))),col="orange",xlab="insertions length",main=file,freq=TRUE,xlim=c(0,20))
      #abline(v=nchar(name),col="red")
      plot(table(sort(as.numeric(unlist(deletions)))),col="cyan",xlab="deletions length",main=file,freq=TRUE,xlim=c(0,20))
      #abline(v=nchar(name),col="red")
    }
  }, error = function(err) {
    print(file)
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ",err))
  })
}
@

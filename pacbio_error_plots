
<<plot error profiles for different motifs>>=
par(
  mfrow = c(4, 4),
  cex.main = 1.3,
  cex.sub = 1.4,
  cex.axis = 1.2
)
require("plyr")
require("dplyr")
require("hash")
require("data.table")

#setwd("~/Documents/Doctoral_Thesis/Dev/Divergence/rhesus/")
#setwd("~/Documents/Doctoral_Thesis/Dev/1kG/filtered/")
#setwd("~/Documents/Doctoral_Thesis/Dev/TCGA/UCEC/")
#setwd("~/Documents/Doctoral_Thesis/Dev/TCGA/All/")
setwd("~/Documents/Doctoral_Thesis/Dev/Illumina/all/")
#setwd("~/Documents/Doctoral_Thesis/Dev/Illumina/plus/")
#setwd("~/Documents/Doctoral_Thesis/Dev/Illumina/minus/")

ITER <- 1000

filenames <- list.files(pattern = "*.mf", full.names = FALSE)

filenames <- filenames[grep("EmptyTmp", filenames,invert=TRUE)]


set.seed(3)

pdf("histograms.pdf")


getPvalue <- function(grp.1, grp.2, comparedTo,paired=TRUE) {
  
  TwoPart <- function(data, group, test="wilcoxon", point.mass=0){
    Index1 <- c(group==1)
    Group1 <- data[Index1]
    Group0 <- data[!Index1]
    n1 <- length(Group1)
    n2 <- length(Group0)
    obs <- c(n1, n2)
    success <- c(sum(Group1!=point.mass), sum(Group0!=point.mass))
    pointmass <- obs-success
    if (sum(success)==0) {
      T2 <- 0
      B2 <- 0
    } else if ((success[1]==0)|(success[2]==0)) {
      T2 <- 0
      B2 <- prop.test(pointmass, obs)$statistic
    } else if ((success[1]==1)|(success[2]==1)){
      T2 <- 0
      B2 <- prop.test(pointmass, obs)$statistic
    } else {
      uniq1 <- length(unique(Group1[Group1!=point.mass]))
      uniq2 <- length(unique(Group0[Group0!=point.mass]))
      if ((uniq1 < 2) & (uniq2 < 2)){
        T2 <- 0
        if (sum(pointmass)==0){
          B2 <- 0
        } else {
          B2 <- prop.test(pointmass, obs)$statistic
        }
      } else if (sum(pointmass)==0){
        B2 <- 0
        if (test=="t.test")
          T2 <- t.test(data~group)$statistic^2
        if (test=="wilcoxon") {
          W <- wilcox.test(data~group, exact=FALSE)$statistic
          mu <- (n1*n2)/2
          sigma <- sqrt((n1*n2*(n1+n2+1))/12)
          T2 <- ((abs(W-mu)-0.5)/sigma)^2
        }
        if (test=="quantiles"){
          T2 <- Reduce(cbind,by(data, groups, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
          T2 <- sum((T2[,2]-T2[,1])^2)
        }
      } else {
        B2 <- prop.test(pointmass, obs)$statistic
        contIndex <- data!=point.mass
        cont <- data[contIndex]
        cGroup <- group[contIndex]
        n1c <- sum(cGroup==1)
        n2c <- sum(cGroup==0)
        if (test=="t.test")
          T2 <- t.test(cont~cGroup)$statistic^2
        if (test=="wilcoxon") {
          W <- wilcox.test(cont~cGroup, exact=FALSE)$statistic
          mu <- (n1c*n2c)/2
          sigma <- sqrt((n1c*n2c*(n1c+n2c+1))/12)
          T2 <- ((abs(W-mu)-0.5)/sigma)^2
        }
        if (test=="quantiles"){
          T2 <- Reduce(cbind,by(data, groups, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
          T2 <- sum((T2[,2]-T2[,1])^2)
        }
      }
    }
    X2 <- B2+T2
    statistic=X2
    return(statistic)
  }
  
  groups <- c(rep(1, length(grp.1)), rep(0, length(grp.2)))
  data <- c(grp.1, grp.2)
  
  if((paired)&(length(grp.1)!=length(grp.2)))
    stop('Different sample size in the two groups, in a paired test!')
  
  
  #diff(by(data, groups, getMQuantile))
  
  print(paste("Control:",sort(table(grp.1))["0"]))
  print(paste("Feature:",sort(table(grp.2))["0"]))
  
  #s<- sample(groups, length(groups), FALSE)
  #diff(by(data, s, getMQuantile))
  
  max.iter <- ITER-1 #500
  examples <- unlist(lapply(1:max.iter, function(x) {
    if(paired){
      perm=which(sample(c(TRUE,FALSE),length(grp.1),replace = TRUE))
      groups_perm=groups
      groups_perm[perm]=groups[length(grp.1)+perm]
      groups_perm[length(grp.1)+perm]=groups[perm]
    }else{
      groups_perm=sample(groups)
    }
    #temp=Reduce(cbind,by(data, groups_perm, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
    #temp=sum((temp[,2]-temp[,1])^2)
    temp=TwoPart(data,groups_perm, test="quantiles")  ###HERE!!!### "wilcoxon" or "quantiles"
    return(temp)
  }))
  
  #test.diff <- Reduce(cbind,by(data, groups, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
  #test.diff=sum((test.diff[,2]-test.diff[,1])^2)
  test.diff=TwoPart(data,groups, test="quantiles")   ###HERE!!!### "wilcoxon" or "quantiles"
  
  # two-tailed test
  pvalue <-
    (sum(examples >= test.diff) + 1) / (max.iter + 1) #from http://danielnee.com/tag/p-value/
  
  #hist(
  # examples,
  #  col = ifelse(pvalue < 0.05, 'red', 'blue'),
  #  breaks = 50,
  #  main = paste("RPerm", main = gsub(".txt", "", gsub(
  #    "ERRORS", "", gsub("10000.", "", gsub(".mf", "", comparedTo))
  #  ))),
  #  xlab = "",
  #  sub = paste(
  #    "pvalue: ",
  #    round(pvalue, 4),
  #    " | C:",
  #    length(grp.1),
  #    " | T:",
  #    length(grp.2),
  #    sep = ""
  #  )
  #)
  #abline(v = test.diff, col = "black", lwd = 4)
  return(pvalue)
}


tryCatch({
  if (file.size(file) > 0) {
    #load motif windows
    data <- read.table(
      file,
      header = F,
      col.names = c("chr", "start", "end", "TOTAL", "MISMATCHES", "INSERTION", "DELETION"),
      fill = TRUE
    )
    
    row <-
      cbind(
        file,
        as.numeric(as.character(mean(
          as.numeric(as.character(as.vector(data$TOTAL))), na.rm = TRUE
        ))),
        as.numeric(as.character(mean(
          as.numeric(as.character(as.vector(data$INSERTION))), na.rm = TRUE
        ))),
        as.numeric(as.character(mean(
          as.numeric(as.character(as.vector(data$DELETION))), na.rm = TRUE
        ))),
        as.numeric(as.character(mean(
          as.numeric(as.character(as.vector(data$MISMATCHES))), na.rm = TRUE
        )))
      )
    
    summary <- rbind(summary, row)
  }
}, error = function(err) {
  # error handler picks up where error was generated
  print(paste("Initial read.table didn't work!:  ", err))
})
}


TOTAL <- hash()
INSERTION <- hash()
DELETION <- hash()
MISMATCHES <- hash()

TOTALcontrols <- hash()
INSERTIONcontrols <- hash()
DELETIONcontrols <- hash()
MISMATCHEScontrols <- hash()

TOTALpvalue <- hash()
INSERTIONpvalue <- hash()
DELETIONpvalue <- hash()
MISMATCHESpvalue <- hash()

#getEmptyValues<- function(i) { 
tryCatch({
  dataEmptyOriginal <-
    read.table(
      "merged_Empty.mf",
      header = F,
      sep = "$",
      col.names = c("V1", "V2", "V3"),
      fill = TRUE
    )
  dataEmpty <-
    as.data.frame(setDT(tstrsplit(
      as.character(dataEmptyOriginal[, 1]), " ", fixed = TRUE
    ))[]) #split by spaces
  
  dataEmpty <- dataEmpty[complete.cases(dataEmpty),]
  valuesEmpty <- as.numeric(as.character(as.vector(dataEmpty[[i]])))
  
  insertionsEmpty <-
    sort(as.numeric(unlist(strsplit(
      gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V2)), ", "
    ))))
  deletionsEmpty <-
    sort(as.numeric(unlist(strsplit(
      gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V3)), ", "
    ))))
  
  return(valuesEmpty)
  
},
error = function(err) {
  # error handler picks up where error was generated
  print(paste("Default empty file does not exist.", err))
})
}

#PLOT 
for (i in c("TOTAL","INSERTION","DELETION","MISMATCHES")) {
  print(i)
  for (file in filenames) {
    print(file)
    tryCatch({
      #load motif windows
      
      data <- read.table(
        file,
        header = F,
        col.names = c("chr", "start", "end", "TOTAL", "MISMATCHES", "INSERTION", "DELETION"),
        fill = TRUE
      )
      
      values <- as.numeric(as.vector(data[[i]]))
      values <- na.omit(values)
      print(mean(values))
      
      
      
      if (length(values) >= 30) {
        #we are only interested in sufficiently populated motifs
        #populate hashes
        tmp_data <- get(i)
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = values
        assign(i, tmp_data)

        hist(
          values,
          col = "gold",
          xlab = "% error",
          main = gsub(".txt", "", gsub(
            "ERRORS", "", gsub("10000.", "", gsub(".mf", "", file))
          )),
          xlim = c(0, 5),
          sub = paste(
            "n=",
            length(values),
            " errorRate=",
            round(mean(values), 4),
            sep =
              ""
          )
        )
        
        #load empty windows
        emptyFile <- gsub(".mf", ".mfEmptyTmp", file)
        
        if (file.exists(emptyFile)) {
          print("empty file exists, will use matching file")
          
          #individial empty files
          
          dataEmpty <-
            
            read.table(
              emptyFile,
              header = F,
              col.names = c("chr", "start", "end", "TOTAL", "MISMATCHES", "INSERTION", "DELETION"),
              fill = TRUE
            )
          
          valuesEmpty <-
            as.numeric(as.character(as.vector(dataEmpty[[i]])))
          valuesEmpty <-na.omit(valuesEmpty)
          print(mean(valuesEmpty))
          
          #populate hash with matching controls  
          tmp_dataEmpty <- get(paste0(i,"controls"))
          tmp_dataEmpty[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = valuesEmpty
          assign(paste0(i,"controls"), tmp_dataEmpty)
          
          
        } else {
          print("ERROR: MISSING CONTROLS")
          
        }
        #compare to either individual all default file with empty values
        pv <- as.numeric(getPvalue(valuesEmpty, values, file,paired=TRUE))
        
        tmp_data <- get(paste0(i,"pvalue"))
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = round(pv, 4) #save pvalue and plot
        assign(paste0(i,"pvalue"), tmp_data)
        
      } else {
        print("Too small sample size.")
      }
    },
    error = function(err) {
      print(file)
      # error handler picks up where error was generated
      print(paste("Read.table didn't work!:  ", err))
    })
  }
}

dev.off()
@

<<>>=

par(mfrow = c(1, 1))


for (i in c("TOTAL","INSERTION","DELETION","MISMATCHES")) { 
  
  names <- gsub("ERRORS", "", gsub(".mf.txt", "", filenames
                                   ))
  f<-values(get(i))
  
  
  for (a in names) {f[[a]] <- f[[a]][f[[a]]!=0]}
  
  c<-values(get(paste0(i, "controls")))
  for (a in names) {c[[a]] <- c[[a]][c[[a]]!=0]}
  
  
  fc<-list(f,c)
  idx <- order(c(seq_along(f), seq_along(c)))
  
  
  box = boxplot(
    c(f[names],c[names])[idx],
    names = TRUE,
    frame = FALSE,
    axis = FALSE,
    labels = TRUE,
    xaxt = "n",
    outline = FALSE,
    border = "gray",
    ylab = "%",
    plot = FALSE
  )
  
  box$stats[c(1,5),]=Reduce(cbind,lapply(c(f[names],c[names])[idx],quantile,probs=c(0.05,0.95),na.rm=TRUE,SIMPLIFY=FALSE))
  
  annotation <- box$n
  annotation[annotation != 0] <- names[which(box$n != 0)]
  annotation[annotation == 0] <- NA
  
  significance <- as.numeric(values(get(paste0(i,"pvalue")))[names])
  
  n <- length(box$n)
  largest_value <- max(box$n)

  perc = round(significance / 1 * 100, 0) # compute pvalue percentages <0,1>
  perc<-as.numeric(na.omit(perc))
  
  colfunc <- colorRampPalette(c("firebrick1","white","white","white","white","white","white","white","white","white"))
  col_perc = colfunc(101)[perc+1] # the maximum sample size has red, indexed from 1
  colscale <- box$n
  colscale[colscale == 0] <-NA
  colscale[!is.na(colscale)] <- col_perc
  
  colscale[grep("Empty", annotation)] <-
    "green"  #assign green to empty windows
  
  
  bxp(
    box,
    outline = FALSE,
    pars = list(
      whisklty = 3,
      staplewex = 0.8,
      boxfill = rep(colscale,each=2)
    ),
    xlab = "Motif",
    ylab = "% error rate",
    xaxt = 'n',
    yaxs ="i",
    main = i,
    border= "darkgray",
    ylim = c(0,0.005)
  )
  
  library("SDMTools")
  #points for the gradient legend
  #pnts = cbind(x =c(0.8,20,20,0.8), y =c(20,20,0.8,0.8))
  
  middle_point<-median(as.numeric(as.character(box$out)),na.rm=TRUE)/2
  
  xl <- 92
  yb <- middle_point
  xr <- 93
  yt <- middle_point*2
  
  
  myLabels<-(gsub("merged_", "", gsub(
    ".mf", "", gsub("FeatureOnly", "", rep(paste(annotation,significance)[1:length(names)],each=2)))
  ))  
  
  text(
    seq(1:(length(names)*2)),
    #0.004,
    2.55*middle_point,
    labels = myLabels,
    srt = 90,
    col = "black",
    cex = 0.7
  )
  abline(h = median(as.numeric(unlist(values(
    get(i)
  )[names][grep("Empty", names)])), na.rm = TRUE), col = "black")
}
@
  

\end{document}

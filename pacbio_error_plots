<<plot error profiles for different motifs>>=
par(
  mfrow = c(4, 4),
  cex.main = 1.3,
  cex.sub = 1.4,
  cex.axis = 1.2
)
require("plyr")
require("dplyr")
require("hash")
require("data.table")

setwd("Illumina")

ITER <- 1000

filenames <- list.files(pattern = "*.mf", full.names = FALSE)

filenames <- filenames[grep("EmptyTmp", filenames,invert=TRUE)]


set.seed(3)

pdf("histograms.pdf")


getPvalue <- function(grp.1, grp.2, comparedTo,paired=TRUE) {
  
  control_non_zero<-round((length(grp.1)-(table(grp.1)["0"]))/length(grp.1),digits=4)
  feature_non_zero<-round((length(grp.2)-(table(grp.2)["0"]))/length(grp.2),digits=4)
  
  if (is.na(control_non_zero)) {
    control_non_zero<-1 #no zeros exist, all values are non-zero
  }
   if (is.na(feature_non_zero)) {
    feature_non_zero<-1 #no zeros exist, all values are non-zero
   }
  print(paste("control_non_zero: ",control_non_zero,"; feature_non_zero:",feature_non_zero))
  
  #populate hash with number of non_zeros  
  tmp_data <- get(paste0(i,"nonzeros"))
  tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = list(control_non_zero,feature_non_zero) 
  assign(paste0(i,"nonzeros"), tmp_data)
  
  TwoPart <- function(data, group, test="wilcoxon", point.mass=0){
    Index1 <- c(group==1)
    Group1 <- data[Index1]
    Group0 <- data[!Index1]
    n1 <- length(Group1)
    n2 <- length(Group0)
    obs <- c(n1, n2)
    success <- c(sum(Group1!=point.mass), sum(Group0!=point.mass))
    pointmass <- obs-success
    if (sum(success)==0) {
      T2 <- 0
      B2 <- 0
    } else if ((success[1]==0)|(success[2]==0)) {
      T2 <- 0
      B2 <- prop.test(pointmass, obs)$statistic
    } else if ((success[1]==1)|(success[2]==1)){
      T2 <- 0
      B2 <- prop.test(pointmass, obs)$statistic
    } else {
      uniq1 <- length(unique(Group1[Group1!=point.mass]))
      uniq2 <- length(unique(Group0[Group0!=point.mass]))
      if ((uniq1 < 2) & (uniq2 < 2)){
        T2 <- 0
        if (sum(pointmass)==0){
          B2 <- 0
        } else {
          B2 <- prop.test(pointmass, obs)$statistic
        }
      } else if (sum(pointmass)==0){
        B2 <- 0
        if (test=="t.test")
          T2 <- t.test(data~group)$statistic^2
        if (test=="wilcoxon") {
          W <- wilcox.test(data~group, exact=FALSE)$statistic
          mu <- (n1*n2)/2
          sigma <- sqrt((n1*n2*(n1+n2+1))/12)
          T2 <- ((abs(W-mu)-0.5)/sigma)^2
       }
        if (test=="quantiles"){
          T2 <- Reduce(cbind,by(data, group, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
          difference <- sum(T2[,2]-T2[,1])
          T2 <- sum((T2[,2]-T2[,1])^2)
        }
      } else {
        B2 <- prop.test(pointmass, obs)$statistic
        contIndex <- data!=point.mass
        cont <- data[contIndex]
        cGroup <- group[contIndex]
        n1c <- sum(cGroup==1)
        n2c <- sum(cGroup==0)
        if (test=="t.test")
          T2 <- t.test(cont~cGroup)$statistic^2
        if (test=="wilcoxon") {
          W <- wilcox.test(cont~cGroup, exact=FALSE)$statistic
          mu <- (n1c*n2c)/2
          sigma <- sqrt((n1c*n2c*(n1c+n2c+1))/12)
          T2 <- ((abs(W-mu)-0.5)/sigma)^2
        }
        if (test=="quantiles"){
          T2 <- Reduce(cbind,by(cont, cGroup, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
          difference <- sum(T2[,2]-T2[,1])
          T2 <- sum((T2[,2]-T2[,1])^2)
        }
      }
    }
    X2 <- B2+T2
   statistic=X2
    return(list(statistic=statistic,difference=difference))
  }
  
  groups <- c(rep(1, length(grp.1)), rep(0, length(grp.2)))
  data <- c(grp.1, grp.2)
  
  if((paired)&(length(grp.1)!=length(grp.2)))
    stop('Different sample size in the two groups, in a paired test!')
  
  
  #diff(by(data, groups, getMQuantile))
  
  #s<- sample(groups, length(groups), FALSE)
  #diff(by(data, s, getMQuantile))
  
  max.iter <- ITER-1 #500
  examples <- unlist(lapply(1:max.iter, function(x) {
    if(paired){
      perm=which(sample(c(TRUE,FALSE),length(grp.1),replace = TRUE))
      groups_perm=groups
      groups_perm[perm]=groups[length(grp.1)+perm]
      groups_perm[length(grp.1)+perm]=groups[perm]
    }else{
      groups_perm=sample(groups)
    }
    #temp=Reduce(cbind,by(data, groups_perm, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
    #temp=sum((temp[,2]-temp[,1])^2)
    temp=TwoPart(data,groups_perm, test="quantiles")$statistic  ###HERE!!!### "wilcoxon" or "quantiles"
    return(temp)
  }))
  
  #test.diff <- Reduce(cbind,by(data, groups, quantile, probs=c(.05, .25, .5, .75, .95),na.rm=TRUE))
  #test.diff=sum((test.diff[,2]-test.diff[,1])^2)
  two.part=TwoPart(data,groups, test="quantiles")   ###HERE!!!### "wilcoxon" or "quantiles"
  test.diff=two.part$statistic
  sign_difference=sign(two.part$difference)
  print(sign_difference)
  # two-tailed test
  pvalue <-
    (sum(examples >= test.diff) + 1) / (max.iter + 1) #from http://danielnee.com/tag/p-value/
  
  #hist(
  # examples,
  #  col = ifelse(pvalue < 0.05, 'red', 'blue'),
  #  breaks = 50,
  #  main = paste("RPerm", main = gsub(".txt", "", gsub(
  #    "ERRORS", "", gsub("10000.", "", gsub(".mf", "", comparedTo))
  #  ))),
  #  xlab = "",
  #  sub = paste(
  #    "pvalue: ",
  #    round(pvalue, 4),
  #    " | C:",
  #    length(grp.1),
  #    " | T:",
  #    length(grp.2),
  #    sep = ""
  #  )
  #)
  #abline(v = test.diff, col = "black", lwd = 4)
  return(list(pvalue=pvalue,sign_difference=sign_difference))
}

TOTAL <- hash()
INSERTION <- hash()
DELETION <- hash()
MISMATCHES <- hash()

TOTALcontrols <- hash()
INSERTIONcontrols <- hash()
DELETIONcontrols <- hash()
MISMATCHEScontrols <- hash()

TOTALpvalue <- hash()
INSERTIONpvalue <- hash()
DELETIONpvalue <- hash()
MISMATCHESpvalue <- hash()

TOTALnonzeros <- hash()
INSERTIONnonzeros <- hash()
DELETIONnonzeros <- hash()
MISMATCHESnonzeros <- hash()

TOTALsign <- hash()
INSERTIONsign <- hash()
DELETIONsign <- hash()
MISMATCHESsign <- hash()

#PLOT 
for (i in c("TOTAL","INSERTION","DELETION","MISMATCHES")) {
  print(i)
  for (file in filenames) {
    print(file)
    tryCatch({
      #load motif windows
      
      data <- read.table(
        file,
        header = F,
        col.names = c("chr", "start", "end", "TOTAL", "MISMATCHES", "INSERTION", "DELETION"),
        fill = TRUE
      )
      
      values <- as.numeric(as.vector(data[[i]]))
      #values <- na.omit(values)
      print(mean(values,na.rm=TRUE))
      
      
      
      if (length(values) >= 30) {
        #we are only interested in sufficiently populated motifs
        #populate hashes
        tmp_data <- get(i)
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = values
        assign(i, tmp_data)

        hist(
          values,
          col = "gold",
          xlab = "% error",
          main = gsub(".txt", "", gsub(
            "ERRORS", "", gsub("10000.", "", gsub(".mf", "", file))
          )),
          xlim = c(0, 5),
          sub = paste(
            "n=",
            length(values),
            " errorRate=",
            round(mean(values), 4),
            sep =
              ""
          )
        )
        
        #load empty windows
        emptyFile <- gsub(".mf", ".mfEmptyTmp", file)
        
        if (file.exists(emptyFile)) {
          print("empty file exists, will use matching file")
          
          #individial empty files
          
          dataEmpty <-
            
            read.table(
              emptyFile,
              header = F,
              col.names = c("chr", "start", "end", "TOTAL", "MISMATCHES", "INSERTION", "DELETION"),
              fill = TRUE
            )
          
          valuesEmpty <-
            as.numeric(as.character(as.vector(dataEmpty[[i]])))
          #valuesEmpty <-na.omit(valuesEmpty)
          print(mean(valuesEmpty,na.rm=TRUE))
          
          #populate hash with matching controls  
          tmp_dataEmpty <- get(paste0(i,"controls"))
          tmp_dataEmpty[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = valuesEmpty
          assign(paste0(i,"controls"), tmp_dataEmpty)
          
          
        } else {
          print("ERROR: MISSING CONTROLS")
          
        }
        #compare to either individual all default file with empty values
        df<-as.data.frame(cbind(valuesEmpty,values))
        missing<-which(is.na(df$values) | is.na(df$valuesEmpty))
        filled<-!(1:(length(values)) %in% missing)
        result=getPvalue(valuesEmpty[filled], values[filled], file,paired=TRUE)
        pv <- as.numeric(result$pvalue)
        sign_difference <- result$sign_difference
        
        tmp_data <- get(paste0(i,"pvalue"))
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = round(pv, 4) #save pvalue and plot
        assign(paste0(i,"pvalue"), tmp_data)
        
        tmp_data <- get(paste0(i,"sign"))
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = sign_difference #save sign
        assign(paste0(i,"sign"), tmp_data)
        
      } else {
        print("Too small sample size.")
      }
    },
    error = function(err) {
      print(file)
      # error handler picks up where error was generated
      print(paste("Read.table didn't work!:  ", err))
    })
  }
}

dev.off()
@

<<>>=

par(mfrow = c(1, 1))


for (i in c("TOTAL","INSERTION","DELETION","MISMATCHES")) { 
  
  names <- gsub("ERRORS", "", gsub(".mf.txt", "", filenames
                                   ))
  f<-values(get(i))
  
  
  for (a in names) {f[[a]] <- f[[a]][f[[a]]!=0]}
  
  c<-values(get(paste0(i, "controls")))
  for (a in names) {c[[a]] <- c[[a]][c[[a]]!=0]}
  
  
  fc<-list(f,c)
  idx <- order(c(seq_along(f), seq_along(c)))
  
  
  box = boxplot(
    c(f[names],c[names])[idx],
    names = TRUE,
    frame = FALSE,
    axis = FALSE,
    labels = TRUE,
    xaxt = "n",
    outline = FALSE,
    border = "gray",
    ylab = "%",
    plot = FALSE
  )
  
  box$stats[c(1,5),]=Reduce(cbind,lapply(c(f[names],c[names])[idx],quantile,probs=c(0.05,0.95),na.rm=TRUE,SIMPLIFY=FALSE))
  
  null_coordinates<-which(box$n==0) #these features don't have sufficiently large sample size
  annotation <- rep(names,each=2)
  annotation[null_coordinates]<-NA
  
  significance <- as.numeric(values(get(paste0(i,"pvalue")))[names])
  signs <- as.numeric(values(get(paste0(i,"sign")))[names])
  print(signs)
  
  n <- length(box$n)/2 #DIVIDED BY TWO BECAUSE WE ARE PLOTTING EACH FEATURE TOGETHER WITH ITS CONTROL
  
  significance[significance<1e-5]=1e-5
  #significance[significance>0.05]=1 # threshold at 5%
  log_pvalue=-log10(significance)
  log_pvalue=signs*log_pvalue     # sign_difference -1 for negative differences, +1 for   positive differences
  colfunc=colorRampPalette(c("red","white","navy"))(n=100-1)    
  # 99 colors from blue to white to red.
  # Blue will correspond to log_pvalue=-5
  # white log_pvalue=0
  # red log_pvalue=5
  color_limits=seq (-5,5,length.out=100)
  col=c(colfunc[unlist(lapply(log_pvalue,function(log) which((log>=color_limits[1:99])&(log<=color_limits[2:100]))[1]))],'green','green')
  col[significance>0.05]<-"white"#non-significant not colored
  
  #colfunc <- colorRampPalette(c("firebrick1","white","white","white","white","white","white","white","white","white"))
  #colscale = colfunc(101)[perc+1] # the maximum sample size has red, indexed from 1
  colscale <- rep(col,each=2)
  
  #colscale[grep("Empty", annotation)] <-
  #  "green"  #assign green to empty windows
  
  
  bxp(
    box,
    outline = FALSE,
    pars = list(
      whisklty = 3,
      staplewex = 0.8,
      boxfill = colscale
    ),
    xlab = "Motif",
    ylab = "error rate",
    xaxt = 'n',
    yaxs ="i",
    main = i,
    border= "darkgray",
    ylim = c(0,0.05)
  )
  
  library("SDMTools")
  #points for the gradient legend
  #pnts = cbind(x =c(0.8,20,20,0.8), y =c(20,20,0.8,0.8))
  
  middle_point<-median(as.numeric(as.character(box$out)),na.rm=TRUE)/2
  
  xl <- 92
  yb <- middle_point
  xr <- 93
  yt <- middle_point*2
  
  
  myLabels<-(gsub("merged_", "", gsub(
    ".mf", "", gsub("FeatureOnly", "", rep(paste(names,significance)[1:length(names)],each=2)))
  ))  
  
  #PLOT LABELS WITH PVALUES
  text(
    seq(1:(length(names)*2)),
    20,#0.004,
    #2*middle_point,
    labels = myLabels,
    srt = 90,
    col = "black",
    cex = 0.7
  )
  
  #PLOT LABELS WITH NON-ZERO COUNTS
    text(
    seq(1:(length(names)*2)),
    0.01,#0.004,
    #3*middle_point,
    labels = paste0(unlist(values(get(paste0(i,"nonzeros"))))*100,"%"),
    srt = 90,
    col = "black",
    cex = 0.7,
    font = 2
  )
  
  abline(h = median(as.numeric(unlist(values(
    get(i)
  )[names][grep("Empty", names)])), na.rm = TRUE), col = "black")
}
@
  

\end{document}

<<plot error profiles for different motifs>>=
par(
  mfrow = c(4, 4),
  cex.main = 1.3,
  cex.sub = 1.4,
  cex.axis = 1.2
)
require("plyr")
require("dplyr")
require("hash")
require("data.table")
#setwd("/Users/alice/Desktop/projects/kinetics/errors_will/merged/formatted")
#setwd("/Users/alice/Desktop/projects/kinetics/errors_will/merged/illumina")
#setwd("/Users/alice/Desktop/projects/kinetics/1kG/")
#setwd("/Users/alice/Desktop/projects/kinetics/illumina/AF0.1")
setwd("/Users/alice/Desktop/projects/kinetics/errors_will/april17/all")

filenames <- list.files(pattern = "*mf", full.names = FALSE)
filenames <- filenames[grepl("FeatureOnly", filenames)]
filenames <- filenames[grep("collapsed", filenames,invert=TRUE)]
#filenames <- filenames[grep("Feature", filenames, invert = TRUE)]
filenames <- filenames[grep("EmptyTmp.txt", filenames,invert=TRUE)]
set.seed(3)

#grp.1 <- round(rlnorm(100, 6)) # With Widget
#grp.2 <- round(rlnorm(100, 6)) # Original page

pdf("histograms.pdf")

getPvalue <- function(grp.1, grp.2, comparedTo) {
  groups <- c(rep(1, length(grp.1)), rep(2, length(grp.2)))
  data <- c(grp.1, grp.2)
  
  diff(by(data, groups, mean))
  
  s <- sample(groups, length(groups), FALSE)
  diff(by(data, s, mean))
  
  max.iter <- 100 #500
  examples <- unlist(lapply(1:max.iter, function(x) {
    diff(by(data, sample(groups, length(groups), FALSE), mean))
  }))
  
  test.diff <- diff(by(data, groups, mean))
  
  # two-tailed test
  pvalue <-
    (sum(abs(examples) > abs(test.diff)) + 1) / (max.iter + 1) #from http://danielnee.com/tag/p-value/
  
  hist(
    examples,
    col = ifelse(pvalue < 0.05, 'red', 'blue'),
    breaks = 50,
    main = paste("RPerm", main = gsub(".txt", "", gsub(
      "ERRORS", "", gsub("10000.", "", gsub(".mf", "", comparedTo))
    ))),
    xlab = "",
    sub = paste(
      "pvalue: ",
      round(pvalue, 4),
      " | C:",
      length(grp.1),
      " | T:",
      length(grp.2),
      sep = ""
    )
  )
  abline(v = test.diff, col = "black", lwd = 4)
  return(pvalue)
}

summary <- NULL
valTable <- NULL
for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0) {
      #load motif windows
      dataOriginal <-
        read.table(
          file,
          header = F,
          sep = "$",
          col.names = c("V1", "V2", "V3"),
          fill = TRUE
        )
      data <-
        as.data.frame(setDT(tstrsplit(
          as.character(dataOriginal[, 1]), " ", fixed = TRUE
        ))[]) #split by spaces
      data <- data[complete.cases(data), ]
      row <-
        cbind(
          file,
          as.numeric(as.character(mean(
            as.numeric(as.character(as.vector(data$V8))), na.rm = TRUE
          ))),
          as.numeric(as.character(mean(
            as.numeric(as.character(as.vector(data$V9))), na.rm = TRUE
          ))),
          as.numeric(as.character(mean(
            as.numeric(as.character(as.vector(data$V10))), na.rm = TRUE
          ))),
          as.numeric(as.character(mean(
            as.numeric(as.character(as.vector(data$V11))), na.rm = TRUE
          )))
        )
      
      summary <- rbind(summary, row)
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Initial read.table didn't work!:  ", err))
  })
}
print(summary)
summary <- summary[complete.cases(summary), ]
summary <- as.data.frame(summary)
colnames(summary) <-
  c("file", "V8", "V9", "V10", "V11") #"total", "insertions", "deletions", "mismatches"
summary <-
  plyr::arrange(summary, as.numeric(as.character(summary$V8)), decreasing =
                  FALSE)
print(summary)
ordered <- summary$file

V8 <- hash()
V9 <- hash()
V10 <- hash()
V11 <- hash()

V8controls <- hash()
V9controls <- hash()
V10controls <- hash()
V11controls <- hash()

V8pvalue <- hash()
V9pvalue <- hash()
V10pvalue <- hash()
V11pvalue <- hash()

getEmptyValues<- function(i) { 
  tryCatch({
    dataEmptyOriginal <-
      read.table(
        "merged_Empty.mf",
        header = F,
        sep = "$",
        col.names = c("V1", "V2", "V3"),
        fill = TRUE
      )
    dataEmpty <-
      as.data.frame(setDT(tstrsplit(
        as.character(dataEmptyOriginal[, 1]), " ", fixed = TRUE
      ))[]) #split by spaces
    
    dataEmpty <- dataEmpty[complete.cases(dataEmpty),]
    valuesEmpty <- as.numeric(as.character(as.vector(dataEmpty[[i]])))
    
    insertionsEmpty <-
      sort(as.numeric(unlist(strsplit(
        gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V2)), ", "
      ))))
    deletionsEmpty <-
      sort(as.numeric(unlist(strsplit(
        gsub("c\\(", "", gsub("\\)", "", dataEmptyOriginal$V3)), ", "
      ))))
    
    return(valuesEmpty)
    
  },
  error = function(err) {
    # error handler picks up where error was generated
    print(paste("Default empty file does not exist.", err))
  })
}

#PLOT ordered from lowest error rate to highest
for (i in names(data[8:11])) {
  #iterate through V8-V11
  print(i)
  for (file in (ordered)) {
    print(file)
    tryCatch({
      #load motif windows
      dataOriginal <-
        read.table(
          file,
          header = F,
          sep = "$",
          col.names = c("V1", "V2", "V3"),
          fill = TRUE
        )
      data <-
        as.data.frame(setDT(tstrsplit(
          as.character(dataOriginal[, 1]), " ", fixed = TRUE
        ))[]) #split by spaces
      values <- as.numeric(as.vector(data[[i]]))
      values <- na.omit(values)
      print(mean(values))
      
      insertions <-
        sort(as.numeric(unlist(strsplit(
          gsub("c\\(", "", gsub("\\)", "", dataOriginal$V2)), ", "
        ))))
      deletions <-
        sort(as.numeric(unlist(strsplit(
          gsub("c\\(", "", gsub("\\)", "", dataOriginal$V3)), ", "
        ))))
      
      
      if (length(values) >= 30) {
        #we are only interested in sufficiently populated motifs
        #populate hashes
        tmp_data <- get(i)
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = values
        assign(i, tmp_data)
        #h9[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V9))
        #h10[gsub("ERROR.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V10))
        #h11[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V11))
        
        hist(
          values,
          col = "gold",
          xlab = "% error",
          main = gsub(".txt", "", gsub(
            "ERRORS", "", gsub("10000.", "", gsub(".mf", "", file))
          )),
          xlim = c(0, 5),
          sub = paste(
            "n=",
            length(values),
            " errorRate=",
            round(mean(values), 4),
            sep =
              ""
          )
        )
        
        #load empty windows
        emptyFile <- gsub(".mf", ".mfEmptyTmp.txt", file)
        
        if (file.exists(emptyFile)) {
          print("empty file exists, will use matching file")
          
          #individial empty files
          dataEmptyOriginal <-
            read.table(
              emptyFile,
              header = F,
              sep = "$",
              col.names = c("V1", "V2", "V3"),
              fill = TRUE
            )
          dataEmpty <-
            as.data.frame(setDT(tstrsplit(
              as.character(dataEmptyOriginal[, 1]), " ", fixed = TRUE
            ))[]) #split by spaces
          dataEmpty <- dataEmpty[complete.cases(dataEmpty), ]
          valuesEmpty <-
            as.numeric(as.character(as.vector(dataEmpty[[i]])))
          valuesEmpty <-na.omit(valuesEmpty)
          print(mean(valuesEmpty))
        
        #populate hash with matching controls  
        tmp_dataEmpty <- get(paste0(i,"controls"))
        tmp_dataEmpty[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = valuesEmpty
        assign(paste0(i,"controls"), tmp_dataEmpty)
          
          insertionsEmpty <-
            sort(as.numeric(unlist(strsplit(
              gsub("c\\(", "", gsub(
                "\\)", "", dataEmptyOriginal$V2
              )), ", "
            ))))
          deletionsEmpty <-
            sort(as.numeric(unlist(strsplit(
              gsub("c\\(", "", gsub(
                "\\)", "", dataEmptyOriginal$V3
              )), ", "
            ))))
          
        } else {
          print("empty file does not exist, will use default file")         #one empty file for all
          valuesEmpty<-getEmptyValues(i) #load data points for empty values
          
        }
        #compare to either individual all default file with empty values
        #getPvalue(valuesEmpty, values, file)
        pv <- as.numeric(getPvalue(na.omit(valuesEmpty), na.omit(values), file))
        
        tmp_data <- get(paste0(i,"pvalue"))
        tmp_data[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = round(pv, 4) #save pvalue and plot
        assign(paste0(i,"pvalue"), tmp_data)
        
        #print(getLengthSignificance(insertionsEmpty, insertions, file))
        #print(getLengthSignificance(deletionsEmpty, deletions, file))
      } else {
        print("Too small sample size.")
      }
    },
    error = function(err) {
      print(file)
      # error handler picks up where error was generated
      print(paste("Read.table didn't work!:  ", err))
    })
  }
}

dev.off()

@

<<>>=

par(mfrow = c(1, 1))


for (i in names(data[8:11])) {
  
  switch(
    i,
    #errorNames = c("TOTAL", "INSERTIONS", "DELETIONS", "MISMATCHES")
    V8 = {
      errorName = "TOTAL"
    },
    V9 = {
      errorName = "INSERTIONS"
    },
    V10 = {
      errorName = "DELETIONS"
    },
    V11 = {
      errorName = "MISMATCHES"
    }
  )
  
      summary <-
        plyr::arrange(summary, as.numeric(as.character(summary[[i]])), decreasing = FALSE)

  #print(summary)
  ordered <- summary$file
  names <- gsub("ERRORS", "", gsub(".mf.txt", "", ordered))
  #percErrorTotal
  box = boxplot(
    values(get(paste0(i,"controls")))[names],
    col = "gold",
    names = TRUE,
    frame = FALSE,
    axis = FALSE,
    labels = TRUE,
    xaxt = "n",
    outline = FALSE,
    border = "gray",
    ylab = "%",
    plot = FALSE
  )
  
  annotation <- box$n
  annotation[annotation != 0] <- names[which(box$n != 0)]
  annotation[annotation == 0] <- NA
  
  significance <- as.numeric(values(get(paste0(i,"pvalue")))[names])
  
  n <- length(box$n)
  largest_value <- max(box$n)
  #perc = round(box$n / largest_value * 100, 0) # compute sample size percentages (the maximum sample size is 1)
  perc = round(significance / 1 * 100, 0) # compute pvalue percentages <0,1>
  perc<-as.numeric(na.omit(perc))
  
  colfunc <- colorRampPalette(c("firebrick1","white","white","white","white","white","white","white","white","white"))
  col_perc = colfunc(101)[perc+1] # the maximum sample size has red, indexed from 1
  colscale <- box$n
  colscale[colscale == 0] <-NA
  colscale[!is.na(colscale)] <- col_perc
  
  colscale[grep("Empty", annotation)] <-
    "green"  #assign green to empty windows
  
  
  bxp(
    box,
    outline = FALSE,
    pars = list(
      whisklty = 3,
      staplewex = 0.8,
      boxfill = colscale
    ),
    xlab = "Motif",
    ylab = "% error rate",
    xaxt = 'n',
    yaxs ="i",
    main = errorName,
    border= "darkgray"
  )
  
  library("SDMTools")
  #points for the gradient legend
#pnts = cbind(x =c(0.8,20,20,0.8), y =c(20,20,0.8,0.8))
  
middle_point<-median(as.numeric(as.character(box$out)),na.rm=TRUE)/2
  
xl <- 92
yb <- middle_point
xr <- 93
yt <- middle_point*2

#rect(
#     xl,
#     head(seq(yb,yt,(yt-yb)/100#),-1),
#     xr,
#     tail(seq(yb,yt,(yt-yb)/100#),-1),
#     col=colfunc(101),
#     lwd=0.075
#    )
#mtext(seq(from=0,to=1,by=0.1),side=4,at=seq(from=yb,to=yt,by=(yt-yb)/10),las=2,cex=0.7)
  
  text(
    1:length(names),
    #0.004,
    1.55*middle_point,
    labels = gsub("merged_", "", gsub(".mf", "", gsub("FeatureOnly", "", annotation))),
    srt = 90,
    col = "black",
    cex = 0.7
  )
  abline(h = median(as.numeric(unlist(values(
    get(i)
  )[names][grep("Empty", names)])), na.rm = TRUE), col = "black")
}
@

<<test>>=
par(mfrow = c(1, 1))

f<-values(get(i))
c<-values(get(paste0(i, "controls")))
fc<-list(f,c)
idx <- order(c(seq_along(f), seq_along(c)))

boxplot(
  c(f[names],c[names])[idx],
  las = 2,
  main = "Features",
  cex = 0.75,
  ylim = c(0, 0.12),
  col = rep(colscale,each=2),
  outline = FALSE
)

myLabels<-(gsub("merged_", "", gsub(
    ".mf", "", gsub("FeatureOnly", "", rep(annotation,each=2)))
  ))

text(
  seq(1:(length(names)*2)),
  0.113,
  #1.55*middle_point,
  labels = myLabels,
  srt = 90,
  col = "darkgray",
  cex = 1
)



@

\end{document}

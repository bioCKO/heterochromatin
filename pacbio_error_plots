
<<plot error profiles for different motifs>>=
par(
  mfrow = c(4, 4),
  cex.main = 1.3,
  cex.sub = 1.4,
  cex.axis = 1.2
)
library("plyr")
library("dplyr")
library("hash")
library("data.table")
setwd("/Users/alice/Desktop/projects/kinetics/errors_will")
filenames <- list.files(pattern = "*mf.txt", full.names = FALSE)
#filenames <- filenames[grepl("FeatureOnly", filenames)]
filenames <- filenames[grepl("windows", filenames)]

set.seed(3)

#grp.1 <- round(rlnorm(100, 6)) # With Widget
#grp.2 <- round(rlnorm(100, 6)) # Original page

getPvalue <- function(grp.1, grp.2, comparedTo) {
  groups <- c(rep(1, length(grp.1)), rep(2, length(grp.2)))
  data <- c(grp.1, grp.2)
  
  diff(by(data, groups, mean))
  
  s <- sample(groups, length(groups), FALSE)
  diff(by(data, s, mean))
  
  max.iter <- 500
  examples <- unlist(lapply(1:max.iter, function(x) {
    diff(by(data, sample(groups, length(groups), FALSE), mean))
  }))
  
  test.diff <- diff(by(data, groups, mean))
  
  # two-tailed test
  pvalue <- (sum(abs(examples) > abs(test.diff)) + 1) / (max.iter + 1) #from http://danielnee.com/tag/p-value/
  
  hist(
    examples,
    col = ifelse(pvalue < 0.05, 'red', 'blue'),
    breaks = 50,
    main = paste("RPerm", main = gsub(".txt", "", gsub(
      "ERRORS", "", gsub("10000.", "", gsub(".mf", "", comparedTo))
    ))),
    xlab = "",
    sub = paste(
      "pvalue: ",
      round(pvalue, 2),
      " | C:",
      length(grp.1),
      " | T:",
      length(grp.2),
      sep = ""
    )
  )
  abline(v = test.diff, col = "black", lwd = 4)
}

summary <- NULL
valTable <- NULL
for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0) {
      #load motif windows
      data <-
        read.table(
          file,
          header = F,
          sep = "$",
          col.names = c("V1", "V2", "V3"),
          fill = TRUE
        )[, 1] #skip information about insertions and deletions
      data <-
        as.data.frame(setDT(tstrsplit(as.character(data), " ", fixed = TRUE))[]) #split by spaces
      data <- data[complete.cases(data), ]
      values <- as.numeric(as.character(as.vector(data$V8)))
      row <- cbind(file, as.numeric(as.character(median(values, na.rm = TRUE))))
      
      summary <- rbind(summary, row)
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Initial read.table didn't work!:  ", err))
  })
}
print(summary)
summary <- summary[complete.cases(summary), ]
summary <- as.data.frame(summary)
colnames(summary) <- c("file", "errorRate")
summary <-
  plyr::arrange(summary, as.numeric(as.character(summary$errorRate)), decreasing =
                  FALSE)
print(summary)
ordered <- summary$file

h8 <- hash()
h9 <- hash()
h10 <- hash()
h11 <- hash()

tryCatch({
  dataEmpty <-
    read.table(
      "Empty.mf.txt",
      header = F,
      sep = "$",
      col.names = c("V1", "V2", "V3"),
      fill = TRUE
    )[, 1] #skip information about insertions and deletions
  dataEmpty <-
    as.data.frame(setDT(tstrsplit(as.character(dataEmpty), " ", fixed = TRUE))[]) #split by spaces
  
  dataEmpty <- dataEmpty[complete.cases(dataEmpty),]
  valuesEmpty <- as.numeric(as.character(as.vector(dataEmpty$V8)))
  
},
error = function(err) {
  # error handler picks up where error was generated
  print(paste("Default empty file does not exist.", err))
})

#PLOT ordered from lowest error rate to highest
for (file in (ordered)) {
  print(file)
  tryCatch({
    #load motif windows
    data <-
      read.table(
        file,
        header = F,
        sep = "$",
        col.names = c("V1", "V2", "V3"),
        fill = TRUE
      )[, 1] #skip information about insertions and deletions
    data <-
      as.data.frame(setDT(tstrsplit(as.character(data), " ", fixed = TRUE))[]) #split by spaces
    values <- as.numeric(as.vector(data$V8))
    values <- values[!is.na(values)]
    
    
    if (length(values) >= 30) { #we are only interested in sufficiently populated motifs
      #populate hashes
      h8[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V8))
      h9[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V9))
      h10[gsub("ERROR.", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V10))
      h11[gsub("ERRORS", "", gsub(".mf.txt", "", file))] = as.numeric(as.vector(data$V11))
      
      hist(
        values,
        col = "gold",
        xlab = "% error",
        main = gsub(".txt", "", gsub(
          "ERRORS", "", gsub("10000.", "", gsub(".mf", "", file))
        )),
        xlim = c(0, 100),
        sub = paste("n=", length(values), " errorRate=", round(mean(values), 2), sep =
                      "")
      )
      
      #load empty windows
      emptyFile <- gsub(".txt", "EmptyTmp.txt", file)
      
      if (file.exists(emptyFile)) {
        print("empty file exists, will use matching file")
        
        #individial empty files
        dataEmpty <-
          read.table(
            emptyFile,
            header = F,
            sep = "$",
            col.names = c("V1", "V2", "V3"),
            fill = TRUE
          )[, 1] #skip information about insertions and deletions
        dataEmpty <-
          as.data.frame(setDT(tstrsplit(
            as.character(dataEmpty), " ", fixed = TRUE
          ))[]) #split by spaces
        dataEmpty <- dataEmpty[complete.cases(dataEmpty), ]
        valuesEmpty <-
          as.numeric(as.character(as.vector(dataEmpty$V8)))
        
      } else {
        print("empty file does not exist, will use default file")         #one empty file for all
        
      }
      #compare to either individual all default file with empty values
      getPvalue(valuesEmpty, values, file)
    } else {
      print("Too small sample size.")
    }
  },
  error = function(err) {
    print(file)
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ", err))
  })
}

@

<<>>=
par(
  mfrow = c(1, 1)
  )

errorTypes = c("h8", "h9", "h10", "h11")

for (et in errorTypes) {
  names <- gsub("ERRORS", "", gsub(".mf.txt", "", ordered))
  #percErrorTotal
  box = boxplot(
    values(get(et))[names],
    col = "gold",
    names = TRUE,
    frame = FALSE,
    axis = FALSE,
    labels = TRUE,
    xaxt = "n",
    main = "CHR 22 ERRORS percError TOTAL",
    ylim = c(0, 60),
    outline = FALSE,
    border = "gray",
    ylab = "%",
    plot = FALSE
  )
  
  n <- length(box$n)
  largest_value <- max(box$n)
  perc = round(box$n / largest_value * 100, 0) # compute sample size percentages (the maximum sample size is 1)
  
  annotation <- box$n
  annotation[annotation != 0] <- names[which(box$n != 0)]
  
  colfunc <- colorRampPalette(c("yellow", "red"))
  col_perc = colfunc(100)[perc] # the maximum sample size has red
  colscale <- box$n
  colscale[colscale != 0] <- col_perc
  
  colscale[grep("Empty", annotation)] <-
    "green"  #assign green to empty windows
  
  switch(et, #errorNames = c("TOTAL", "INSERTIONS", "DELETIONS", "MISMATCHES")
         h8 = {
         errorName="TOTAL"
         },
         h9 = {
         errorName="INSERTIONS"
         },
         h10 = {
         errorName="DELETIONS"
         },
         h11 = {
         errorName="MISMATCHES"
         })

  
  bxp(
    box,
    outline = FALSE,
    pars = list(
      whisklty = 3,
      staplewex = 0.8,
      boxfill = colscale
    ),
    xlab = "motif",
    xaxt = 'n',
    main = errorName
  )
  
  #mtext(annotation,cex=0.5,srt=90,col="black",side=1,at=1:length(names),las=3)
  text(
    1:length(names),
    1.8*median(as.numeric(unlist(values(get(et))[names][grep("Empty", names)]))),
    labels = gsub("windows10000", "", annotation),
    srt = 90,
    col = "blue",
    cex = 0.8
  )
  abline(h=median(as.numeric(unlist(values(get(et))[names][grep("Empty", names)])), na.rm = TRUE),col="black")
}
@

<<other hists>>=
#percErrorIns
boxplot(values(h9)[names],col="orange",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError INSERTIONS",ylim=c(0,30),outline=FALSE,border="gray",ylab="%")
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h9)),las=3)
text(1:length(names),20,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h9[["Empty"]], na.rm = TRUE),col="blue")

#percErrorDel
boxplot(values(h10)[names],col="cyan",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError DELETIONS",ylim=c(0,30),outline=FALSE,border="gray",ylab="%")
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h10)),las=3)
text(1:length(names),15,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h10[["Empty"]], na.rm = TRUE),col="blue")

#percErrorMism
boxplot(values(h11)[names],col="green",names=FALSE,frame=FALSE,axis=FALSE,labels = FALSE,xaxt = "n",main="CHR 22 ERRORS percError MISMATCHES",ylim=c(0,40),outline=FALSE,border="gray",ylab="%")
mtext(names,cex=0.5,srt=90,col="black",side=1,at=1:length(keys(h11)),las=3)
text(1:length(names),35,labels=names,srt=90,col="blue",cex=0.5)
abline(h=median(h11[["Empty"]], na.rm = TRUE),col="blue")
@

<<>>=


summary<-NULL
for (file in (ordered)) {
  tryCatch({
    if (file.size(file) > 0){
      
      print(file)
      #load motif windows
      data<-as.data.frame(read.table(file, header = F,col.names=c("V1","V2","V3","V4","V5","V6","V7","V8","V9","V10","V11"), fill=TRUE))
      data<-data[complete.cases(data),]
      values<-as.numeric(as.character(as.vector(data$V8)))
      row<-cbind(file,as.numeric(as.character(median(values, na.rm = TRUE))))
      
      if (length(values) >= 50) {
        boxplot(values,col="gold",main=gsub(".ERRORS10000onlyFeature","", file),ylim=c(0,100),frame=F)
      }
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ",err))
  })
}
@






\end{document}
<<>>=
par(mfrow=c(3,2))
setwd("/Users/alice/Desktop/projects/kinetics/errors_will/lengths")
filenames <- list.files(pattern="*mf.txt", full.names=FALSE)

for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0){
      name<-gsub("22.ERRORS10000onlyFeature.","",gsub(".mf.txt","",file))
      #load motif windows
      data<-as.data.frame(read.table(file, header = F,sep='$'))
      insertions<-strsplit(gsub(" c\\(","",gsub("\\) ","",data$V2)),", ")
      deletions<-strsplit(gsub(" c\\(","",gsub("\\) ","",data$V3)),", ")
      print(dim(data))
      plot(table(sort(as.numeric(unlist(insertions)))),col="orange",xlab="insertions length",main=file,freq=TRUE,xlim=c(0,20))
      #abline(v=nchar(name),col="red")
      plot(table(sort(as.numeric(unlist(deletions)))),col="cyan",xlab="deletions length",main=file,freq=TRUE,xlim=c(0,20))
      #abline(v=nchar(name),col="red")
    }
  }, error = function(err) {
    print(file)
    # error handler picks up where error was generated
    print(paste("Read.table didn't work!:  ",err))
  })
}
@

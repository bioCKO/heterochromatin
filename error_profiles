\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

<<>>=
library("h5r")
library("pbh5")
library("data.table")

setwd("/Users/alice/Desktop/projects/kinetics/errors_will/")
args <- commandArgs(trailingOnly = TRUE)
pathTocmpFile="/Users/alice/Desktop/projects/kinetics/errors_will/" #args[1]
reference="21" #args[2]

#cmpH5file=paste(pathTocmpFile,"chr",reference,"_P6.cmp.h5",sep="")
cmpH5file=paste(pathTocmpFile,"coord_check_21_chr21_P6.cmp.h5",sep="")
cmp = PacBioCmpH5( cmpH5file )

##get IPDs by template position
res = getByTemplatePosition( cmp, f = getIPD )
RES<-as.data.table(res)  
setkey(RES, "position","read","ref")

#RAW DATA
#save(RES,file="/Users/alice/Desktop/projects/kinetics/errors_will/RES.Rda")

@

<<>>=

<<toy_test>>=
library("qpcR")

plotIPDperPASS <- function(chunk,filename) {
  par(mfrow = c(2, 2))
  
  
  if (length(unique(sort(chunk$idx)))>1) { #if more than one subread is available, then plot
    myColors <- c("red", "blue")
    pass = 1
    chunk<-chunk[order(chunk$rStart)]
    l<-unique(sort(chunk$linkage))
    bind<-NULL
    
    for (idx_chunk in split(chunk, by=c("idx"))) { #for each molecule, go subread by subread in increasing order
      i<-unique(idx_chunk$idx) #idx
      print(i)#}
      
      s<-unique(sort(idx_chunk$strand))
      
      #bind<-qpcR:::cbind.na(bind,paste(idx_chunk$position,idx_chunk$elt))
      IPDbyPOS<-as.data.frame(cbind(idx_chunk$position,idx_chunk$elt))
      
      if (is.null(bind)) {
        bind<-IPDbyPOS
      } else {
        bind<-merge(bind,IPDbyPOS,by="V1",all=TRUE)
      }
      
      colnames(bind)[ncol(bind)]<-paste(i,pass,s)
      #
      
      plot(
        idx_chunk$position,
        idx_chunk$elt,
        ylim = c(0, 10),
        col = myColors[s + 1],
        ylab = "IPD",
        xlab = "position in reference",
        main = paste("molecule:",l,"| PASS:", pass,"|", basename(filename)),
        sub=paste("idx:",unique(sort(idx_chunk$idx)),"strand:",s,"rStart:",unique(sort(idx_chunk$rStart)),"rEnd:",unique(sort(idx_chunk$rEnd)))
      )
      pass = pass + 1
      #print(head(idx_chunk))
    }
      write.table( #only plot if molecule has multiple subreads
        as.matrix(bind),
        file = paste0(filename,"_",l,".IPDs.txt"),
        col.names = TRUE,
        row.names = FALSE,
        quote = FALSE,
        sep = "\t",
        append = TRUE
      )
  }
}
@


<<RUN THIS>>=

##get IPDs by template position
#res = getByTemplatePosition(cmp, f = getIPD)
#RES <- as.data.table(res)
#setkey(RES, "position", "read", "ref")


getWindow <- function(arguments,filename) { #getWindow(unlist(coordinates0[2,]))
  #print(arguments)
  chr <- arguments[1]
  start <- as.numeric(arguments[2])
  end <- as.numeric(arguments[3])
  strand <- arguments[4]
  
  rates <- (getErrorRate(start, end, strand, filename))
  percErrorTotal <- (rates[[2]] + rates[[3]] + rates[[4]]) / rates[[1]] *
    100
  percErrorIns <- (rates[[2]]) / rates[[1]] * 100
  percErrorDel <- (rates[[3]]) / rates[[1]] * 100
  percErrorMism <- (rates[[4]]) / rates[[1]] * 100
  
  return(
    paste(
      reference,
      start,
      end,
      rates[[1]],
      rates[[2]],
      rates[[3]],
      rates[[4]],
      percErrorTotal,
      percErrorIns,
      percErrorDel,
      percErrorMism,
      paste0("$", rates[[5]], "$", rates[[6]]),
      sep = " "
    )
  )
  #rows<-rbind(rows,t)
  #write.table(t, file=filename, col.names = FALSE,row.names = FALSE,quote=FALSE,sep="\t",append=TRUE)
  
}

getErrorRate <- function(start, end, refStrand, filename) {
  # start
  # end
  w <-
    RES[position >= start &
          position < end] #cut out relevant portion from the data
  #print(dim(w))
  
  for (molecule_chunk in split(w, w$linkage)) { 
    plotIPDperPASS(molecule_chunk, filename) 
  }
  
  #w<-w[w$strand==refStrand,]
  #print(dim(w))
  
  if (nrow(w) > 0) {
    totalRows <- nrow(w)
    
    insertion_lengths <-
      unlist(lapply(unique(w$idx), function(x)
        (rle(w[idx == x]$ref)$lengths[rle(w[idx == x]$ref)$values == "-"])))
    if (!length(insertion_lengths) > 0) {
      insertion_lengths <- NA
    }
    
    deletion_lengths <-
      unlist(lapply(unique(w$idx), function(x)
        (rle(w[idx == x]$read)$lengths[rle(w[idx == x]$read)$values == "-"])))
    if (!length(deletion_lengths) > 0) {
      deletion_lengths <- NA
    }
    
    insertionRows <- nrow(w[as.character(w$ref) == "-", ])
    deletionRows <- nrow(w[as.character(w$read) == "-", ])
    mismatchRows <-
      nrow(w[as.character(w$ref) != as.character(w$read) &
               (as.character(w$ref) != "-") & (as.character(w$read) != "-"), ])
    
    return(list(
      totalRows,
      insertionRows,
      deletionRows,
      mismatchRows,
      list(as.numeric(insertion_lengths)),
      list(as.numeric(deletion_lengths))
    ))
  }
}

processMotif <- function(motif) {
  print("ITERATION")
  print(reference)
  print(motif)
  
  filename <-
    paste(folder,
          "/",
          reference,
          ".ERRORS",
          ".",
          basename(motif),
          ".txt",
          sep = "")
  motifFile <- paste(folder, "/", motif, sep = "")
  
  if (file.exists(motifFile)) {
    #.mf file exists
    coordinates <-
      read.table(motifFile,col.names = paste0("V",seq_len(max(count.fields(motifFile)))), fill = TRUE)[, 1:3] #read only first three columns
    
    coordinates <- subset(coordinates, V1 == reference) #subset only to specific chromosome #paste("chr",reference,sep="")
    
    rows <- apply(coordinates, 1, function(x)
      getWindow(x,filename)
    )
    
    coordinates0 <- as.data.table(c(coordinates,"0"))
    coordinates1 <- as.data.table(c(coordinates,"1"))
    
    colnames(coordinates0)<-c("V1", "V2", "V3","V4")
    colnames(coordinates1)<-c("V1", "V2", "V3","V4")
    
    setkey(coordinates0, "V1", "V2", "V3","V4")
    setkey(coordinates1, "V1", "V2", "V3","V4")
    
    
    
    #rows<-NULL
    #rows0 <- apply(coordinates0, 1, function(x)
    #  getWindow(x,filename)
    #)
    #rows1 <- apply(coordinates1, 1, function(x)
    #  getWindow(x,filename)
    #)
    
    #if (file.exists(paste0(filename,"_0strand.txt"))) {
    #  file.remove(paste0(filename,"_0strand.txt")) #file with results already exists, remove before writing
    #}
    
    #if (file.exists(paste0(filename,"_1strand.txt"))) {
    #  file.remove(paste0(filename,"_1strand.txt")) #file with results already exists, remove before writing
    #}
    
    #system.time(
    #  write.table(
    #    as.matrix(rows0),
    #    file = paste0(filename,"_0strand.txt"),
    #    col.names = FALSE,
    #    row.names = FALSE,
    #    quote = FALSE,
    #    sep = "\t",
    #    append = TRUE
    #  )
    #)

    #system.time(
    #  write.table(
    #    as.matrix(rows1),
    #    file = paste0(filename,"_1strand.txt"),
    #    col.names = FALSE,
    #    row.names = FALSE,
    #    quote = FALSE,
    #    sep = "\t",
    #    append = TRUE
    #  )
    #)
  } else {
    print("File does not exist, skipping.")
  }
}

#list<-c("AAAC","AAAG","AAAT","AACC","AACG","AAC","AACT","AAGC","AAGG","AAG","AAGT","AATC","AATG","AAT","AATT","ACAG","ACAT","ACCC","ACCG","ACC","ACCT","ACGG","ACG","AC","ACTC","ACTG","ACT","ACTract","ACTT","AGAT","AGCC","AGCG","AGC","AGCT","AGGC","AGGG","AGG","AGGT","AG","AGTC","AGTG","AGT","AGTT","A","APhasedRepeats","ATCC","ATC","ATCT","ATGC","ATGG","ATG","ATGT","AT","ATTC","ATTG","ATT","ATTract","ATTT","CCCG","CCCT","CCG","CCTG","CCT","CCTT","CGCT","CGGG","CGG","CGGT","CG","CGT","C","CpGIsland","CTGG","CTG","CTGT","CT","CTTG","CTT","CTTT","DirectRepeats","Empty","GCTract","GGGT","GGT","GGTT","G","GQuadruplexMotifs","GT","GTT","GTTT","InvertedRepeats","MirrorRepeats","PuPy","PuTract","PyTract","TGTract","T","ZDNAMotifs")

library(parallel)

list<-c("GQuadPlusFeatureOnly.mf","GQuadMinusFeatureOnly.mf","MirrorRepeatsFeatureOnly.mf") #my loooong list of motifs, shortened for illustration purposes

# Calculate the number of cores
#no_cores <- detectCores() - 1
# Initiate cluster
#cl <- makeCluster(no_cores,type="FORK")

#print("PARALLEL")
#ptm <- proc.time() #start timer
#parLapply(cl, list,
#          function(motif)
#            processMotif(motif)
#)
#stopCluster(cl)
#proc.time() - ptm

print("NON-PARALLEL")
ptm <- proc.time()
for (motif in list) { 
  processMotif(motif) #PROCESS EACH MOTIF INDIVIDUALLY
}
proc.time() - ptm #stop timer

print("Done.")


@


<<PLOT DATA>>=
par(mfrow = c(2, 1))

setwd("/Users/alice/Desktop/projects/kinetics/errors_will/old/10000/")
filenames <- list.files(pattern = "*IPDs.txt", full.names = FALSE)
filenames<-filenames[grepl("Quad",filenames)]

myColors<-c("blue","red")

for (file in (filenames)) {
  d <- read.table(file, sep = "\t", header = TRUE)
  print(dim(d))
  
  strand<-as.numeric((unlist(strsplit(as.character(colnames(d)[2]),"[.]"))[3]))
  myCol<-myColors[as.numeric(strand+1)]
  
  plot(
    d$V1,
    d[, 2],
    pch = '1',
    col = myCol,
    ylim = c(0, 10),
    ylab = "IPD",
    sub = "position on reference",
    main=basename(file),
    xlab="",
    las=2
  )
  
  for (c in 3:ncol(d)) {
    print("---")
    print(c)
    strand<-as.numeric((unlist(strsplit(as.character(colnames(d)[c]),"[.]"))[3]))
    print(strand)
    myCol<-myColors[as.numeric(strand+1)]
    print(myCol)
    points(d$V1, d[, c], pch = as.character(c - 1), col=myCol)
  }
  
  points(d$V1, rowMeans(d[, 2:ncol(d)], na.rm = TRUE), pch = "*",col="black",cex=2)
  
  dt <- t(d)
  colnames(dt) <- dt[1, ]
  dt <- dt[-1, ]
  
  boxplot(dt, las = 2)
}
@
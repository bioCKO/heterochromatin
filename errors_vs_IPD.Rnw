\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

<<>>=
par(mfrow = c(2, 2))
library("outliers")
setwd("/Users/alice/Desktop/projects/kinetics/errors_vs_IPD")

if (!require("gplots")) {
   install.packages("gplots", dependencies = TRUE)
   library(gplots)
   }
if (!require("RColorBrewer")) {
   install.packages("RColorBrewer", dependencies = TRUE)
   library(RColorBrewer)
   }



calculatePvalue <- function(i, dataErrors, meanIPDperRow) {
  switch(
    i,
    #errorNames = c("TOTAL", "INSERTIONS", "DELETIONS", "MISMATCHES")
    V8 = {
      errorName = "TOTAL"
    },
    V9 = {
      errorName = "INSERTIONS"
    },
    V10 = {
      errorName = "DELETIONS"
    },
    V11 = {
      errorName = "MISMATCHES"
    }
  )
  errorPerRow <- as.numeric(as.character(dataErrors[[i]]))
  #print(length(errorPerRow))
  #boxplot(errorPerRow,col="gold")
  
  df <- data.frame(meanIPDperRow, errorPerRow)
  if (dim(df)[1] >= 30) {
  plot(
    errorPerRow,
    meanIPDperRow,
    pch = ".",
    col = "darkgray",
    main = errorName,
    sub = file,
    xlim = c(0, 100),
    xlab = "% ERROR RATE",
    ylab = "mean IPD per window"
  )
  mylm <- lm(meanIPDperRow ~ errorPerRow, data = df)
  #plot(mylm)
  
  summary(mylm)
  abline(mylm, col = "red")
  pvalue <- as.numeric(round(coef(summary(mylm))[, "Pr(>|t|)"][2], 2))
  mtext(pvalue,
        col = ifelse(pvalue < 0.05, 'red', 'blue'),
        side = 4)
  return(pvalue)
  } else {
    print("not sufficient sample size")
  }
}
plotFile <- function(file) {
  dataOriginal <-
    read.table(
      file,
      header = F,
      sep = "$",
      col.names = c("V1", "V2", "V3"),
      fill = TRUE
    )
  dataErrors <-
    as.data.frame(setDT(tstrsplit(
      as.character(dataOriginal[, 1]), " ", fixed = TRUE
    ))[]) #split by spaces
  dataIPDs <-
    as.data.frame(setDT(tstrsplit(
      as.character(dataOriginal[, 3]), "\t", fixed = FALSE
    ))[])[-(1:4)] #split by spaces and remove columns with region and feature lengths, keep only IPDs
  dataIPDs <- data.matrix(dataIPDs)
  meanIPDperRow <-
    apply(dataIPDs, 1, function(x)
      mean(x, na.rm = TRUE))
  
  pvaluesForMotif<-sapply(names(dataErrors[8:11]), function(x,y) calculatePvalue(x,dataErrors,meanIPDperRow))
  return(unlist(pvaluesForMotif))
  #for (i in names(dataErrors[8:11])) { #iterate through V8-V11
  #  calculatePvalue(i)
  #}
}

filenames <- list.files(pattern = "*.mf", full.names = FALSE)
summary<-NULL

for (file in (filenames)) {
  tryCatch({
    if (file.size(file) > 0) {
      #load motif windows
      print(file)
      pvaluesForMotif<-plotFile(file)
      
      if (pvaluesForMotif[1]=="not sufficient sample size") {
        print("skipping") 
      } else { 
        print("OK, returning values")
        row <-
          c(
            file,
            pvaluesForMotif
          )
        
        row<-as.data.frame(t(row))
        colnames(row)[1]=c("motif")
        summary <- rbind(summary, row)  
      }
      
    }
  }, error = function(err) {
    # error handler picks up where error was generated
    print(paste("Initial read.table didn't work!:  ", err))
  })
}
@

<<>>=
par(mfrow=c(1,2),cex.lab=0.5)
toPlot<-summary
rownames(toPlot)<-gsub("OUT_","",gsub("FeatureOnly.mf","",toPlot[,1]))
toPlot<-toPlot[-1]
colnames(toPlot)<-c("TOTAL", "INS", "DEL", "MISM")
toPlot<-as.matrix(toPlot)
class(toPlot) <- "numeric" 

#lmat = rbind(c(0,3),c(2,1),c(0,4))
lmat = rbind(c(3,4),c(2,1))
lwid = c(0.4,5)
my_palette <- colorRampPalette(c("red","white","white","white","white","white","white","white","white","white"))(n = 101)
heatmap.2(toPlot,dendrogram='none',Rowv=TRUE,Colv=FALSE,col=my_palette,trace="row",tracecol="gray",lmat=lmat,lwid=lwid,margins = c(6.5, 6))

@

<<>>=

library(gplots)
 
myCol <- c("gray15", "gray25", "blue", "green", "yellow", "orange", "gray25", "gray15")
# Defining breaks for the color scale
myBreaks <- c(-1, -0.06, -0.05, -0.001, 0, 0.001, 0.05, 0.06, 1)
# pdf("result_heatmap.pdf", width = 30, height = 30)
 
hm <- heatmap.2(toPlot, scale="none", Rowv=T, Colv=T,
col = myCol, ## using your colors
breaks = myBreaks, ## using your breaks
#                 dendrogram = "none",  ## to suppress warnings
margins=c(8,8), cexRow=0.8, cexCol=0.8, key=FALSE, keysize=1.5,
trace="none")
legend("topleft", fill = myCol, cex=0.6,
legend = c(">0.6", "0.6 to 0.05", "0.049 to 0.001 (OR <1)", "0.001 to 0 (OR <1)", "0 to 0.001 (OR >1)", "0.001 to 0.049 (OR >1)", "0.05 to 0.6", ">0.6"))

#summary <- summary[!is.na(as.numeric(as.character(summary$pvaluesForMotif))),]
#View(summary)

#n <- dim(summary)[1]
#total<-summary[seq(1, n, 4)[1:(n/4)],] 
#total <-
#        plyr::arrange(total, as.numeric(as.character(total$pvaluesForMotif)), decreasing = FALSE)
#View(total)


#file <- "OUT"
#file<-"OUT_CGGGn"
#file<-"OUT_TnFeatureOnly.mf"

#View(dataIPDs)
@



\end{document}
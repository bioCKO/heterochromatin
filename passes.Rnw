\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

<<>>=
library("h5r")
library("pbh5")
library("data.table")
par(mfrow = c(3, 3))
setwd("/Users/alice/Desktop/projects/kinetics/passes")
cmpH5 = PacBioCmpH5("/Users/alice/Desktop/projects/kinetics/passes/chr21_P6.cmp.h5")
#passesStat <-read.table("/Users/alice/Desktop/projects/kinetics/passes/21.EmptyFeatureOnly.mf.gff.intersect")
passesStat <-read.table("/Users/alice/Desktop/projects/kinetics/passes/21.GQuadPlusFeatureOnly.mf.gff.intersect")

linkage <- paste(cmpH5$movieName, cmpH5$moleculeID, sep = "_")
association <-
  as.data.frame(cbind(cmpH5$ID, as.numeric(factor(linkage))))
association$movieName <- cmpH5$movieName
association$moleculeID <- cmpH5$moleculeID
association$alignedStrand <- cmpH5$alignedStrand
association$rStart <- cmpH5$rStart
association$rEnd <- cmpH5$rEnd
colnames(association) <-
  c("idx",
    "linkage",
    "movieName",
    "moleculeID",
    "strand",
    "rStart",
    "rEnd")
association <- as.data.table(association)

#start <- 9829589
#end <- 9829616
#chromosome <- "chr21"

calculateIPDforWindow <-
  function(chromosome, start, end, numberOfPasses) {
    subreads <- getReadsInRange(cmpH5, chromosome, start, end)
    start<-as.integer(start)
    end<-as.integer(end)
    print(paste(chromosome,start,end))
    #print(subreads)
    #print(paste("number of passes:",numberOfPasses))
    
    #print(length(subreads))
    myColors <- c("red", "blue")
    bind <- NULL
    
    molecules <-
      association[association$idx %in% subreads,] #keep only associated subreads
    
    for (mol in split(molecules, by = c("moleculeID"))) {
      m <- unique(mol$moleculeID)
      #print(paste("moleculeID: ",m))
      chunk <- mol[order(mol$rStart)] #sort subreads by rStart
      subreads_in_mol <- length(mol$idx)
      print(subreads_in_mol)
      #View(getAlignmentBlock(cmpH5, chromosome, start, end))
      if (subreads_in_mol == numberOfPasses) {
        #print("==========")
        print(paste(chromosome, start, end))
        #print(paste("sufficient number of passes: ", length(mol$idx)))
        #print(chunk$strand)
        ideal_strandness0 <- rep(c(0, 1), length(chunk$strand) / 2)
        ideal_strandness1 <- rep(c(1, 0), length(chunk$strand) / 2)
        
        if (all.equal(chunk$strand, ideal_strandness0) == TRUE |
            all.equal(chunk$strand, ideal_strandness1) == TRUE) {
          #strands interleave as expected
          print("strands interleaved correctly ") #todo: add adjacency control for reads
          #print(chunk$strand)
          pass <- 0
          for (id in chunk[order(chunk$rStart)]$idx) {
            i<-sort(unique(id))
            pass <- pass + 1
            #print(paste("subread idx:",i,"pass",pass))
            tposIPD <- getByTemplatePosition(cmpH5, idx = i)
            tposIPD <- as.data.table(tposIPD)
            #print(dim(tposIPD))
            idx_chunk <- subset(tposIPD,tposIPD$position >= start & tposIPD$position <= end)
            #print(dim(idx_chunk))
            #print(nrow(idx_chunk))
            
            if (nrow(idx_chunk) == 0) {
              print("empty dataframe")
              #break #the whole molecule should be skipped
            } else {
              #print("non-empty dataframe")
              
              #print(head(idx_chunk, n = 1))
              #print(tail(idx_chunk, n = 1))
              
              s <- unique(sort(idx_chunk$strand))
              
              #bind<-qpcR:::cbind.na(bind,paste(idx_chunk$position,idx_chunk$elt))
              IPDbyPOS <-
                as.data.frame(cbind(idx_chunk$position, idx_chunk$elt))
              colnames(IPDbyPOS)[1] <- "position"
              
              insertionRows <-
                as.data.frame(idx_chunk[as.character(idx_chunk$ref) == "-", c("position", "read")])
              deletionRows <-
                as.data.frame(idx_chunk[as.character(idx_chunk$read) == "-", c("position", "ref")])
              mismatchRows <-
                as.data.frame(idx_chunk[as.character(idx_chunk$ref) != as.character(idx_chunk$read) &
                                          (as.character(idx_chunk$ref) != "-") &
                                          (as.character(idx_chunk$read) != "-"), c("position", "read")])
              
              #add data about insertions, deletions, mismatches
              IPDbyPOS <-
                merge(
                  IPDbyPOS,
                  mismatchRows,
                  all.x = TRUE,
                  all.y = TRUE,
                  suffixes = paste(i, pass, s)
                )
              IPDbyPOS <-
                merge(
                  IPDbyPOS,
                  deletionRows,
                  all.x = TRUE,
                  all.y = TRUE,
                  suffixes = paste(i, pass, s)
                )
              IPDbyPOS <-
                merge(
                  IPDbyPOS,
                  insertionRows,
                  all.x = TRUE,
                  all.y = TRUE,
                  suffixes = paste(i, pass, s)
                )
              colnames(IPDbyPOS) <-
                c("position", "insertions", "elt", "deletions")
              
              if (is.null(bind)) {
                bind <- IPDbyPOS
              } else {
                bind <- merge(
                  bind,
                  IPDbyPOS,
                  by = "position",
                  all.y = TRUE,
                  all.x = TRUE
                )
              }
              
              colnames(bind)[(ncol(bind) - 2):ncol(bind)] <-
                paste(colnames(bind)[(ncol(bind) - 2):ncol(bind)], i, pass, s)
              #
              
              plot(
                idx_chunk$position,
                idx_chunk$elt,
                col = myColors[s + 1],
                ylim = c(0, 60),
                ylab = "IPD",
                xlab = "position in reference",
                main = paste("molecule:", m, "| PASS:", pass, "|", "nan"),
                sub = paste(
                  "idx:",
                  i,
                  "strand:",
                  s,
                  "rStart:",
                  chunk[chunk$idx == i]$rStart,
                  "rEnd:",
                  chunk[chunk$idx == i]$rEnd
                )
              )
              #print(head(idx_chunk))
              
              
              
              filename <-
                paste0(paste(chromosome, start, end, sep = "-"),
                       "-",
                       m,
                       ".IPDs.txt")
              if (file.exists(filename))
                file.remove(filename) #remove file if it exists
              
              write.table(
                #only plot if molecule has multiple subreads
                as.matrix(bind),
                file = filename,
                col.names = TRUE,
                row.names = FALSE,
                quote = FALSE,
                sep = "\t",
                append = TRUE
              )
              
            }
          }
          bind<-NULL
        }
      }
    }
  }

#calculateIPDforWindow("chr21", 10473900, 10473999, 4)
coordinates <-
  as.data.frame(unique(cbind(
    passesStat$V1, as.numeric(passesStat$V4), as.numeric(passesStat$V5)
  )))
by(coordinates, 1:nrow(coordinates), function(row)
  calculateIPDforWindow(paste0("chr", row[1]), row[2], row[3], 4))


#all_molecules<-unique(passesStat$V12)
#print(head(all_molecules))

#calculateIPDforWindow(chromosome,start,end)

@

<<PLOT DATA>>=
#par(mfrow = c(2, 1))

setwd("/Users/alice/Desktop/projects/kinetics/passes")
#pdf(file="/Users/alice/Desktop/projects/kinetics/errors_will/old/10000/molecules.pdf")
filenames <- list.files(pattern = "*IPDs.txt", full.names = FALSE)
#filenames<-filenames[grepl("Quad",filenames)]
#filenames<-filenames[1:100]

myColors<-c("blue","red")

IPDlistPASS1 <- list()
IPDlistPASS2 <- list()
IPDlistPASS3 <- list()
IPDlistPASS4 <- list()
IPDlistPASS5 <- list()
IPDlistPASS6 <- list()

returnIPDfittedIntoWindow<-function(start,end,values) {
  window_span <-as.data.frame(seq(start,end,1))
  colnames(window_span)<-c("position")
  colnames(values)<-c("position","elt")
  fitted_into_window<-merge(window_span,values,all.x=TRUE)
  fitted_into_window<-aggregate(elt ~ position,data=fitted_into_window, FUN=mean, na.action=na.pass) #full window with multiple values per position replaced by mean
  return(fitted_into_window)
}

for (file in (filenames)) {
  d <- read.table(file, sep = "\t", header = TRUE)
  print(file)
  #print(dim(d))
  
  start<-as.integer(unlist(strsplit(file, "-", fixed = TRUE))[2]) #window start
  end<-as.integer(unlist(strsplit(file, "-", fixed = TRUE))[3]) #window end
  
  
  filled_valuesPASS1<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, 3]))))
  filled_valuesPASS2<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, 6]))))
  filled_valuesPASS3<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, 9]))))
  filled_valuesPASS4<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, 12]))))
  #filled_valuesPASS5<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, 15]))))
  #filled_valuesPASS6<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, 18]))))
  
  IPDlistPASS1[[length(IPDlistPASS1)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS1)$elt
  IPDlistPASS2[[length(IPDlistPASS2)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS2)$elt
  IPDlistPASS3[[length(IPDlistPASS3)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS3)$elt
  IPDlistPASS4[[length(IPDlistPASS4)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS4)$elt
  #IPDlistPASS5[[length(IPDlistPASS5)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS5)$elt
  #IPDlistPASS6[[length(IPDlistPASS6)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS6)$elt
  
  
  .f = function() {

  strand<-as.numeric((unlist(strsplit(as.character(colnames(d)[3]),"[.]"))[4]))
  myCol<-myColors[as.numeric(strand+1)]
  
  plot(
    d[, 1],
    d[, 3],
    pch = '1',
    col = myCol,
    ylim = c(0, 60),
    ylab = "IPD",
    sub = "position on reference",
    main=basename(file),
    xlab="",
    las=2
  )
  
  for (c in seq(6, ncol(d), 3)) {
    #print("---")
    #print(c)
    strand<-as.numeric((unlist(strsplit(as.character(colnames(d)[c]),"[.]"))[4]))
    #print(strand)
    myCol<-myColors[as.numeric(strand+1)]
    #print(myCol)
    #print(colnames(d)[c])
    mySymbol<-as.character((c/3))
    #print(mySymbol)
    points(d[, 1], d[, c], pch = mySymbol, col=myCol)
  }
  
  #plot insertions
  for (c in seq(2, ncol(d), 3)) {
    points(d[,1],rep(10+c,length(d[,1])),pch=as.character(d[,c]),col="darkgreen")
  }
  
  #plot deletions
  for (c in seq(4, ncol(d), 3)) {
    points(d[,1],rep(9.5+c,length(d[,1])),pch=as.character(d[,c]),col="orange")
  }
  
  points(d[,1], rowMeans(d[, seq(3, ncol(d), 3)], na.rm = TRUE), pch = "*",col="gray",cex=2)
  }
  #dt <- t(d)
  #colnames(dt) <- dt[1, ]
  #dt <- dt[-1, ]
  
  #boxplot(dt, las = 2)
}

#IPDlistPASS1

paddVector<-function(myVector) { #add paddings of NAs as flanks to the feature in order to form 100bp window
  len<-100-length(unlist(myVector))
  return(as.vector(mapply( function(x,y) c(rep( NA , round(y/2)), x , rep( NA , y-round(y/2)) ) , myVector , len, SIMPLIFY = TRUE))) #todo: check +-1 error
}

paddedIPDlistPASS1<-list()
paddedIPDlistPASS2<-list()
paddedIPDlistPASS3<-list()
paddedIPDlistPASS4<-list()

for (i in 1:length(IPDlistPASS1)) { 
  print(i)
  paddedIPDlistPASS1[i]<-list(paddVector(IPDlistPASS1[i]))
}

for (i in 1:length(IPDlistPASS2)) { 
  print(i)
  paddedIPDlistPASS2[i]<-list(paddVector(IPDlistPASS2[i]))
}

for (i in 1:length(IPDlistPASS3)) { 
  print(i)
  paddedIPDlistPASS3[i]<-list(paddVector(IPDlistPASS3[i]))
}

for (i in 1:length(IPDlistPASS4)) { 
  print(i)
  paddedIPDlistPASS4[i]<-list(paddVector(IPDlistPASS4[i]))
}


#IPDlistPASS2
#IPDlistPASS3
#IPDlistPASS4

par(mfrow=c(3,2))

plot(
  1:100,
  rowMeans(sapply(paddedIPDlistPASS1, unlist), na.rm = TRUE),
  main = paste0("PASS 1, n=", length(IPDlistPASS1)),
  ylim = c(0, 10),
  ylab = "Mean IPD across all windows",
  xlab = "window",
  col = "red",
  pch = 21
)

plot(
  1:100,
  rowMeans(sapply(paddedIPDlistPASS2, unlist), na.rm = TRUE),
  main = paste0("PASS 2, n=", length(IPDlistPASS2)),
  ylim = c(0, 10),
  ylab = "Mean IPD across all windows",
  xlab = "window",
  col = "red",
  pch = 21
)

plot(
  1:100,
  rowMeans(sapply(paddedIPDlistPASS3, unlist), na.rm = TRUE),
  main = paste0("PASS 3, n=", length(IPDlistPASS3)),
  ylim = c(0, 10),
  ylab = "Mean IPD across all windows",
  xlab = "window",
  col = "red",
  pch = 21
)

plot(
  1:100,
  rowMeans(sapply(paddedIPDlistPASS4, unlist), na.rm = TRUE),
  main = paste0("PASS 4, n=", length(IPDlistPASS4)),
  ylim = c(0, 10),
  ylab = "Mean IPD across all windows",
  xlab = "window",
  col = "red",
  pch = 21
)


@

\end{document}
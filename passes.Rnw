\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

<<>>=
library("h5r")
library("pbh5")
library("data.table")

calculateIPDforWindow <-
  function(chromosome, start, end, numberOfPasses) {
    subreads <- getReadsInRange(cmpH5, chromosome, start, end)
    start<-as.integer(start)
    end<-as.integer(end)
    print(paste(chromosome,start,end))
    #print(subreads)
    #print(paste("number of passes:",numberOfPasses))
    
    #print(length(subreads))
    myColors <- c("red", "blue")
    bind <- NULL
    
    molecules <-
      association[association$idx %in% subreads,] #keep only associated subreads
    
    if (nrow(molecules)>0) {
      for (mol in split(molecules, by = c("moleculeID"))) {
        m <- unique(mol$moleculeID)
        #print(paste("moleculeID: ",m))
        chunk <- mol[order(mol$rStart)] #sort subreads by rStart
        subreads_in_mol <- length(mol$idx)
        #print(subreads_in_mol)
        #View(getAlignmentBlock(cmpH5, chromosome, start, end))
        if (subreads_in_mol == numberOfPasses) {
          #print("==========")
          print(paste(chromosome, start, end))
          #print(paste("sufficient number of passes: ", length(mol$idx)))
          #print(chunk$strand)
          ideal_strandness0 <- rep(c(0, 1), length(chunk$strand) / 2)
          ideal_strandness1 <- rep(c(1, 0), length(chunk$strand) / 2)
          
          if (all.equal(chunk$strand, ideal_strandness0) == TRUE |
              all.equal(chunk$strand, ideal_strandness1) == TRUE) {
            #strands interleave as expected
            print("strands interleaved correctly ") #todo: add adjacency control for reads
            write(chunk$strand,file="strandFile.txt",append=TRUE)
            pass <- 0
            for (id in chunk[order(chunk$rStart)]$idx) {
              i<-sort(unique(id))
              pass <- pass + 1
              #print(paste("subread idx:",i,"pass",pass))
              tposIPD <- getByTemplatePosition(cmpH5, idx = i)
              tposIPD <- as.data.table(tposIPD)
              #print(dim(tposIPD))
              idx_chunk <- subset(tposIPD,tposIPD$position >= start & tposIPD$position <= end)
              #print(dim(idx_chunk))
              #print(nrow(idx_chunk))
              
              if (nrow(idx_chunk) == 0) {
                print("empty dataframe")
                #break #the whole molecule should be skipped
              } else {
                #print("non-empty dataframe")
                
                #print(head(idx_chunk, n = 1))
                #print(tail(idx_chunk, n = 1))
                
                s <- unique(sort(idx_chunk$strand))
                
                #bind<-qpcR:::cbind.na(bind,paste(idx_chunk$position,idx_chunk$elt))
                IPDbyPOS <-
                  as.data.frame(cbind(idx_chunk$position, idx_chunk$elt))
                colnames(IPDbyPOS)[1] <- "position"
                
                insertionRows <-
                  as.data.frame(idx_chunk[as.character(idx_chunk$ref) == "-", c("position", "read")])
                deletionRows <-
                  as.data.frame(idx_chunk[as.character(idx_chunk$read) == "-", c("position", "ref")])
                mismatchRows <-
                  as.data.frame(idx_chunk[as.character(idx_chunk$ref) != as.character(idx_chunk$read) &
                                            (as.character(idx_chunk$ref) != "-") &
                                            (as.character(idx_chunk$read) != "-"), c("position", "read")])
                
                #add data about insertions, deletions, mismatches
                IPDbyPOS <-
                  merge(
                    IPDbyPOS,
                    mismatchRows,
                    all.x = TRUE,
                    all.y = TRUE,
                    suffixes = paste(i, pass, s)
                  )
                IPDbyPOS <-
                  merge(
                    IPDbyPOS,
                    deletionRows,
                    all.x = TRUE,
                    all.y = TRUE,
                    suffixes = paste(i, pass, s)
                  )
                IPDbyPOS <-
                  merge(
                    IPDbyPOS,
                    insertionRows,
                    all.x = TRUE,
                    all.y = TRUE,
                    suffixes = paste(i, pass, s)
                  )
                colnames(IPDbyPOS) <-
                  c("position", "insertions", "elt", "deletions")
                
                if (is.null(bind)) {
                  bind <- IPDbyPOS
                } else {
                  bind <- merge(
                    bind,
                    IPDbyPOS,
                    by = "position",
                    all.y = TRUE,
                    all.x = TRUE
                  )
                }
                
                colnames(bind)[(ncol(bind) - 2):ncol(bind)] <-
                  paste(colnames(bind)[(ncol(bind) - 2):ncol(bind)], i, pass, s)
                #
                
                plot(
                  idx_chunk$position,
                  idx_chunk$elt,
                  col = myColors[s + 1],
                  ylim = c(0, 60),
                  ylab = "IPD",
                  xlab = "position in reference",
                  main = paste("molecule:", m, "| PASS:", pass, "|", "nan"),
                  sub = paste(
                    "idx:",
                    i,
                    "strand:",
                    s,
                    "rStart:",
                    chunk[chunk$idx == i]$rStart,
                    "rEnd:",
                    chunk[chunk$idx == i]$rEnd
                  )
                )
                #print(head(idx_chunk))
                
                
                
                filename <-
                  paste0(paste(chromosome, start, end, sep = "-"),
                         "-",
                         m,
                         ".IPDs.txt")
                if (file.exists(filename))
                  file.remove(filename) #remove file if it exists
                
                write.table(
                  #only plot if molecule has multiple subreads
                  as.matrix(bind),
                  file = filename,
                  row.names = FALSE,
                  quote = FALSE,
                  sep = "\t",
                  append = TRUE
                )
                
              }
            }
            bind<-NULL
          }
        }
      }}
  }

par(mfrow = c(3, 3))
setwd("/Users/alice/Desktop/projects/kinetics/passes")
pdf("plots.pdf")
#cmpH5 = PacBioCmpH5("/Users/alice/Desktop/projects/kinetics/passes/chr21_P6.cmp.h5")
#passesStat <-read.table("/Users/alice/Desktop/projects/kinetics/passes/21.EmptyFeatureOnly.mf.gff.intersect")

for (myChromosome in seq(20,22,1)) {
  print(myChromosome)
  cmpH5candidate<-paste0("chr",myChromosome,"_P6.cmp.h5")
  
  if (file.exists(cmpH5candidate)) { #does cmp file exists?
    
    passesStatCandidate<-paste0(myChromosome,".GQuadMinusFeatureOnly.mf.gff.intersect")
    
    if (file.exists(passesStatCandidate)) { #does passesStat file exists?
      
      print(cmpH5candidate)
      print(passesStatCandidate)
      
      cmpH5 = PacBioCmpH5(cmpH5candidate) #read cmp file
      passesStat <-read.table(passesStatCandidate) #read passesStat candidate
      
      linkage <- paste(cmpH5$movieName, cmpH5$moleculeID, sep = "_")
      association <-
        as.data.frame(cbind(cmpH5$ID, as.numeric(factor(linkage))))
      association$movieName <- cmpH5$movieName
      association$moleculeID <- cmpH5$moleculeID
      association$alignedStrand <- cmpH5$alignedStrand
      association$rStart <- cmpH5$rStart
      association$rEnd <- cmpH5$rEnd
      colnames(association) <-
        c("idx",
          "linkage",
          "movieName",
          "moleculeID",
          "strand",
          "rStart",
          "rEnd")
      association <- as.data.table(association)
      
      coordinates <-as.data.frame(unique(cbind(passesStat$V1, as.numeric(passesStat$V4), as.numeric(passesStat$V5)
      )))
      print(head(coordinates))
      by(coordinates, 1:nrow(coordinates), function(row) calculateIPDforWindow(paste0("chr", row[1]), row[2], row[3], 4))
    }
    else {
      print("intersect file does not exist")
      print(passesStatCandidate)
    }
    
  } else {
    print("cmp file does not exist")
    print(cmpH5candidate)
  }
  
}

dev.off()
@

<<PLOT DATA>>=
#par(mfrow = c(2, 1))

setwd("/Users/alice/Desktop/projects/kinetics/passes")
#pdf(file="/Users/alice/Desktop/projects/kinetics/errors_will/old/10000/molecules.pdf")
filenames <- list.files(pattern = "*IPDs.txt", full.names = FALSE)
#filenames<-filenames[grepl("Quad",filenames)]
#filenames<-filenames[1:100]

myColors<-c("blue","red")

IPDlistPASS1_0 <- list()
IPDlistPASS1_1 <- list()
IPDlistPASS2_0 <- list()
IPDlistPASS2_1 <- list()
IPDlistPASS3_0 <- list()
IPDlistPASS3_1 <- list()
IPDlistPASS4_0 <- list()
IPDlistPASS4_1 <- list()
IPDlistPASS5_0 <- list()
IPDlistPASS5_1 <- list()
IPDlistPASS6_0 <- list()
IPDlistPASS6_1 <- list()


returnIPDfittedIntoWindow<-function(start,end,values) {
  window_span <-as.data.frame(seq(start,end,1))
  colnames(window_span)<-c("position")
  colnames(values)<-c("position","elt")
  fitted_into_window<-merge(window_span,values,all.x=TRUE)
  fitted_into_window<-aggregate(elt ~ position,data=fitted_into_window, FUN=mean, na.action=na.pass) #full window with multiple values per position replaced by mean
  return(fitted_into_window)
}

for (file in (filenames)) {
  d <- read.table(file, sep = "\t", header = TRUE)
  print(file)
  #print(dim(d))
  
  start<-as.integer(unlist(strsplit(file, "-", fixed = TRUE))[2]) #window start
  end<-as.integer(unlist(strsplit(file, "-", fixed = TRUE))[3]) #window end
  

  for (actual_pass in seq(1,4,1)) {
    c<-actual_pass*3
    strand<-as.numeric((unlist(strsplit(as.character(colnames(d)[c]),"[.]"))[4]))
    print(paste("pass:",c,"strand",strand))
    filled_valuesPASS<-as.data.frame(unique(na.omit(cbind(d[, 1],d[, c])))) #pick columns 3,6,9,12,15,18 depending on the pass we are interested in
    
    if (strand==0) {
      myVariable<-paste0("IPDlistPASS",actual_pass,"_",strand)
      tmp_data <- get(myVariable)
      tmp_data[[length(tmp_data)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS)$elt
      assign(myVariable, tmp_data)
    } else {
      myVariable<-paste0("IPDlistPASS",actual_pass,"_",strand)
      tmp_data <- get(myVariable)
      tmp_data[[length(tmp_data)+1]] <- returnIPDfittedIntoWindow(start,end,filled_valuesPASS)$elt
      assign(myVariable, tmp_data)
    }
    
  }
  
  .f = function() {

  myCol<-myColors[as.numeric(strand+1)]
  
  plot(
    d[, 1],
    d[, 3],
    pch = '1',
    col = myCol,
    ylim = c(0, 60),
    ylab = "IPD",
    sub = "position on reference",
    main=basename(file),
    xlab="",
    las=2
  )
  
  for (c in seq(6, ncol(d), 3)) {
    #print("---")
    #print(c)
    strand<-as.numeric((unlist(strsplit(as.character(colnames(d)[c]),"[.]"))[4]))
    #print(strand)
    myCol<-myColors[as.numeric(strand+1)]
    #print(myCol)
    #print(colnames(d)[c])
    mySymbol<-as.character((c/3))
    #print(mySymbol)
    points(d[, 1], d[, c], pch = mySymbol, col=myCol)
  }
  
  #plot insertions
  for (c in seq(2, ncol(d), 3)) {
    points(d[,1],rep(10+c,length(d[,1])),pch=as.character(d[,c]),col="darkgreen")
  }
  
  #plot deletions
  for (c in seq(4, ncol(d), 3)) {
    points(d[,1],rep(9.5+c,length(d[,1])),pch=as.character(d[,c]),col="orange")
  }
  
  points(d[,1], rowMeans(d[, seq(3, ncol(d), 3)], na.rm = TRUE), pch = "*",col="gray",cex=2)
  }
  #dt <- t(d)
  #colnames(dt) <- dt[1, ]
  #dt <- dt[-1, ]
  
  #boxplot(dt, las = 2)
}

#IPDlistPASS1

paddVector<-function(myVector) { #add paddings of NAs as flanks to the feature in order to form 100bp window
  len<-100-length(unlist(myVector))
  return(as.vector(mapply( function(x,y) c(rep( NA , round(y/2)), x , rep( NA , y-round(y/2)) ) , myVector , len, SIMPLIFY = TRUE))) #todo: check +-1 error
}

#PLOT
par(mfrow=c(4,2))
motif<-"motif"
all_passes<-4

for (actual_pass in seq(1,all_passes,1)) { 
  for (strand in c(0,1)) {
    #print(paste("pass:",actual_pass,"strand",strand))
    myVariable<-paste0("IPDlistPASS",actual_pass,"_",strand)
    print(myVariable)
    tmp_data <- get(myVariable)
    paddedIPDlist<-list()
    
    for (i in 1:length(tmp_data)) { 
      #print(i)
      paddedIPDlist[i]<-list(paddVector(tmp_data[i]))
    }
    
    maxvalue<-round(max(rowMeans(sapply(paddedIPDlist, unlist), na.rm = TRUE),na.rm = TRUE),2)
    minvalue<-round(min(rowMeans(sapply(paddedIPDlist, unlist), na.rm = TRUE),na.rm = TRUE),2)
    
    
    #plot(
    #  1:100,
    #  rowMeans(sapply(paddedIPDlist, unlist), na.rm = TRUE),
    #  main = paste0("pass:",actual_pass," strand: ",strand," n=", length(paddedIPDlist)," | min=",minvalue," max=",maxvalue),
    #  ylim = c(0, 6),
    #  ylab = "Mean IPD across all windows",
    #  xlab = "window",
    #  col = myColors[strand + 1],
    #  sub = motif,
    #  pch = 21
    #)
    plot(
      1:100,
      apply(sapply(paddedIPDlist, unlist), 1, quantile, probs = c(0.9),  na.rm = TRUE) ,
      main = paste0("pass:",actual_pass," strand: ",strand," n=", length(paddedIPDlist)," | min=",minvalue," max=",maxvalue),
      ylim = c(0, 6),
      ylab = "IPD across all windows",
      xlab = "window",
      col = myColors[strand + 1],
      sub = motif,
      pch = 20
    )
    abline(h=1,col="gray")
    #apply(sapply(paddedIPDlist, unlist), 1, sd,  na.rm = TRUE)
  }
}

@

\end{document}